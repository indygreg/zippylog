// Generated by the lua-protobuf compiler.
// You shouldn't be editing this file manually
//
// source proto file: zippylog/protocol/request.proto

#ifndef LUA_PROTOBUF_zippylog_protocol_request_H
#define LUA_PROTOBUF_zippylog_protocol_request_H

#include "lua-protobuf.h"
#include <zippylog/protocol/request.pb.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <lua.h>

// register all messages in this package to a Lua state
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_open(lua_State *L);

// Message Ping
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_Ping_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_Ping_pushcopy(lua_State *L, const ::zippylog::protocol::request::Ping &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_Ping_pushreference(lua_State *L, ::zippylog::protocol::request::Ping *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_Ping_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_Ping_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_Ping_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_Ping_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_Ping_clear(lua_State *L);

// end of message Ping

// Message GetFeatures
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetFeatures_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_GetFeatures_pushcopy(lua_State *L, const ::zippylog::protocol::request::GetFeatures &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_GetFeatures_pushreference(lua_State *L, ::zippylog::protocol::request::GetFeatures *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetFeatures_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetFeatures_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetFeatures_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetFeatures_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetFeatures_clear(lua_State *L);

// end of message GetFeatures

// Message GetStoreInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStoreInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_GetStoreInfo_pushcopy(lua_State *L, const ::zippylog::protocol::request::GetStoreInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_GetStoreInfo_pushreference(lua_State *L, ::zippylog::protocol::request::GetStoreInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStoreInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStoreInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStoreInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStoreInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStoreInfo_clear(lua_State *L);

// required uint32 version = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStoreInfo_clear_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStoreInfo_get_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStoreInfo_set_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStoreInfo_has_version(lua_State *L);

// end of message GetStoreInfo

// Message GetBucketInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_GetBucketInfo_pushcopy(lua_State *L, const ::zippylog::protocol::request::GetBucketInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_GetBucketInfo_pushreference(lua_State *L, ::zippylog::protocol::request::GetBucketInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_clear(lua_State *L);

// required uint32 version = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_clear_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_get_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_set_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_has_version(lua_State *L);

// optional string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetBucketInfo_has_path(lua_State *L);

// end of message GetBucketInfo

// Message GetStreamSetInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_pushcopy(lua_State *L, const ::zippylog::protocol::request::GetStreamSetInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_pushreference(lua_State *L, ::zippylog::protocol::request::GetStreamSetInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_clear(lua_State *L);

// required uint32 version = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_clear_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_get_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_set_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_has_version(lua_State *L);

// optional string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamSetInfo_has_path(lua_State *L);

// end of message GetStreamSetInfo

// Message GetStreamInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_GetStreamInfo_pushcopy(lua_State *L, const ::zippylog::protocol::request::GetStreamInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_GetStreamInfo_pushreference(lua_State *L, ::zippylog::protocol::request::GetStreamInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_clear(lua_State *L);

// required uint32 version = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_clear_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_get_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_set_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_has_version(lua_State *L);

// optional string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStreamInfo_has_path(lua_State *L);

// end of message GetStreamInfo

// Message GetStream
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_GetStream_pushcopy(lua_State *L, const ::zippylog::protocol::request::GetStream &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_GetStream_pushreference(lua_State *L, ::zippylog::protocol::request::GetStream *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_clear(lua_State *L);

// required uint32 version = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_clear_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_get_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_set_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_has_version(lua_State *L);

// optional string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_has_path(lua_State *L);

// optional uint64 start_offset = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_clear_start_offset(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_get_start_offset(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_set_start_offset(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_has_start_offset(lua_State *L);

// optional uint32 max_response_bytes = 4
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_clear_max_response_bytes(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_get_max_response_bytes(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_set_max_response_bytes(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_has_max_response_bytes(lua_State *L);

// optional uint32 max_response_envelopes = 5
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_clear_max_response_envelopes(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_get_max_response_envelopes(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_set_max_response_envelopes(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_GetStream_has_max_response_envelopes(lua_State *L);

// end of message GetStream

// Message WriteEnvelope
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_WriteEnvelope_pushcopy(lua_State *L, const ::zippylog::protocol::request::WriteEnvelope &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_WriteEnvelope_pushreference(lua_State *L, ::zippylog::protocol::request::WriteEnvelope *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_clear(lua_State *L);

// required uint32 version = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_clear_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_get_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_set_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_has_version(lua_State *L);

// optional string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_has_path(lua_State *L);

// repeated bytes envelope = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_clear_envelope(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_get_envelope(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_set_envelope(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_size_envelope(lua_State *L);

// optional bool acknowledge = 4
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_clear_acknowledge(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_get_acknowledge(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_set_acknowledge(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_has_acknowledge(lua_State *L);

// optional bool synchronous = 5
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_clear_synchronous(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_get_synchronous(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_set_synchronous(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelope_has_synchronous(lua_State *L);

// end of message WriteEnvelope

// Message WriteEnvelopeFromMessages
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_pushcopy(lua_State *L, const ::zippylog::protocol::request::WriteEnvelopeFromMessages &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_pushreference(lua_State *L, ::zippylog::protocol::request::WriteEnvelopeFromMessages *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_clear(lua_State *L);

// required uint32 version = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_clear_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_get_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_set_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_has_version(lua_State *L);

// optional string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_has_path(lua_State *L);

// repeated bytes message = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_clear_message(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_get_message(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_set_message(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_size_message(lua_State *L);

// repeated uint32 message_namespace = 4
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_clear_message_namespace(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_get_message_namespace(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_set_message_namespace(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_size_message_namespace(lua_State *L);

// repeated uint32 message_type = 5
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_clear_message_type(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_get_message_type(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_set_message_type(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_WriteEnvelopeFromMessages_size_message_type(lua_State *L);

// end of message WriteEnvelopeFromMessages

// Message SubscribeStoreChanges
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_pushcopy(lua_State *L, const ::zippylog::protocol::request::SubscribeStoreChanges &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_pushreference(lua_State *L, ::zippylog::protocol::request::SubscribeStoreChanges *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_clear(lua_State *L);

// required uint32 version = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_clear_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_get_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_set_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_has_version(lua_State *L);

// repeated string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeStoreChanges_size_path(lua_State *L);

// end of message SubscribeStoreChanges

// Message SubscribeEnvelopes
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_pushcopy(lua_State *L, const ::zippylog::protocol::request::SubscribeEnvelopes &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_pushreference(lua_State *L, ::zippylog::protocol::request::SubscribeEnvelopes *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_clear(lua_State *L);

// required uint32 version = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_clear_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_get_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_set_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_has_version(lua_State *L);

// repeated string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_size_path(lua_State *L);

// optional string lua_code = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_clear_lua_code(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_get_lua_code(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_set_lua_code(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeEnvelopes_has_lua_code(lua_State *L);

// end of message SubscribeEnvelopes

// Message SubscribeKeepalive
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_pushcopy(lua_State *L, const ::zippylog::protocol::request::SubscribeKeepalive &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_pushreference(lua_State *L, ::zippylog::protocol::request::SubscribeKeepalive *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_clear(lua_State *L);

// required uint32 version = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_clear_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_get_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_set_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_has_version(lua_State *L);

// optional bytes id = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeKeepalive_has_id(lua_State *L);

// end of message SubscribeKeepalive

// Message SubscribeCancel
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_SubscribeCancel_pushcopy(lua_State *L, const ::zippylog::protocol::request::SubscribeCancel &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_request_SubscribeCancel_pushreference(lua_State *L, ::zippylog::protocol::request::SubscribeCancel *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_clear(lua_State *L);

// required uint32 version = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_clear_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_get_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_set_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_has_version(lua_State *L);

// optional bytes id = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_request_SubscribeCancel_has_id(lua_State *L);

// end of message SubscribeCancel

#ifdef __cplusplus
}
#endif

#endif