// Generated by the lua-protobuf compiler.
// You shouldn't be editing this file manually
//
// source proto file: zippylog/protocol/response.proto

#ifndef LUA_PROTOBUF_zippylog_protocol_response_H
#define LUA_PROTOBUF_zippylog_protocol_response_H

#include "lua-protobuf.h"
#include <zippylog/protocol/response.pb.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <lua.h>

// register all messages in this package to a Lua state
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_open(lua_State *L);

// Message Pong
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Pong_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_Pong_pushcopy(lua_State *L, const ::zippylog::protocol::response::Pong &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_Pong_pushreference(lua_State *L, ::zippylog::protocol::response::Pong *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Pong_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Pong_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Pong_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Pong_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Pong_clear(lua_State *L);

// end of message Pong

// Message FeatureSpecification
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_FeatureSpecification_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_FeatureSpecification_pushcopy(lua_State *L, const ::zippylog::protocol::response::FeatureSpecification &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_FeatureSpecification_pushreference(lua_State *L, ::zippylog::protocol::response::FeatureSpecification *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_FeatureSpecification_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_FeatureSpecification_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_FeatureSpecification_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_FeatureSpecification_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_FeatureSpecification_clear(lua_State *L);

// repeated uint32 supported_message_version = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_FeatureSpecification_clear_supported_message_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_FeatureSpecification_get_supported_message_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_FeatureSpecification_set_supported_message_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_FeatureSpecification_size_supported_message_version(lua_State *L);

// end of message FeatureSpecification

// Message StreamSegmentStart
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_StreamSegmentStart_pushcopy(lua_State *L, const ::zippylog::protocol::response::StreamSegmentStart &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_StreamSegmentStart_pushreference(lua_State *L, ::zippylog::protocol::response::StreamSegmentStart *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_clear(lua_State *L);

// optional string path = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_has_path(lua_State *L);

// optional uint64 offset = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_clear_offset(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_get_offset(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_set_offset(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentStart_has_offset(lua_State *L);

// end of message StreamSegmentStart

// Message StreamSegmentEnd
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_pushcopy(lua_State *L, const ::zippylog::protocol::response::StreamSegmentEnd &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_pushreference(lua_State *L, ::zippylog::protocol::response::StreamSegmentEnd *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_clear(lua_State *L);

// optional uint64 offset = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_clear_offset(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_get_offset(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_set_offset(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_has_offset(lua_State *L);

// optional uint32 bytes_sent = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_clear_bytes_sent(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_get_bytes_sent(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_set_bytes_sent(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_has_bytes_sent(lua_State *L);

// optional uint32 envelopes_sent = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_clear_envelopes_sent(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_get_envelopes_sent(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_set_envelopes_sent(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_StreamSegmentEnd_has_envelopes_sent(lua_State *L);

// end of message StreamSegmentEnd

// Message SubscribeAck
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_SubscribeAck_pushcopy(lua_State *L, const ::zippylog::protocol::response::SubscribeAck &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_SubscribeAck_pushreference(lua_State *L, ::zippylog::protocol::response::SubscribeAck *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_has_id(lua_State *L);

// optional uint32 ttl = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_clear_ttl(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_get_ttl(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_set_ttl(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscribeAck_has_ttl(lua_State *L);

// end of message SubscribeAck

// Message SubscriptionStart
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscriptionStart_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_SubscriptionStart_pushcopy(lua_State *L, const ::zippylog::protocol::response::SubscriptionStart &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_SubscriptionStart_pushreference(lua_State *L, ::zippylog::protocol::response::SubscriptionStart *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscriptionStart_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscriptionStart_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscriptionStart_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscriptionStart_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscriptionStart_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscriptionStart_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscriptionStart_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscriptionStart_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_SubscriptionStart_has_id(lua_State *L);

// end of message SubscriptionStart

// Message WriteAck
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_WriteAck_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_WriteAck_pushcopy(lua_State *L, const ::zippylog::protocol::response::WriteAck &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_WriteAck_pushreference(lua_State *L, ::zippylog::protocol::response::WriteAck *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_WriteAck_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_WriteAck_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_WriteAck_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_WriteAck_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_WriteAck_clear(lua_State *L);

// optional uint32 envelopes_written = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_WriteAck_clear_envelopes_written(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_WriteAck_get_envelopes_written(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_WriteAck_set_envelopes_written(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_WriteAck_has_envelopes_written(lua_State *L);

// end of message WriteAck

// Message Error
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_Error_pushcopy(lua_State *L, const ::zippylog::protocol::response::Error &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_response_Error_pushreference(lua_State *L, ::zippylog::protocol::response::Error *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_clear(lua_State *L);

// optional enum code = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_clear_code(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_get_code(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_set_code(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_has_code(lua_State *L);

// optional string msg = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_clear_msg(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_get_msg(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_set_msg(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_response_Error_has_msg(lua_State *L);

// end of message Error

#ifdef __cplusplus
}
#endif

#endif