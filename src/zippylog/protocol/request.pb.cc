// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "zippylog/protocol/request.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace zippylog {
namespace protocol {
namespace request {

namespace {

const ::google::protobuf::Descriptor* GetFeatures_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetFeatures_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetStoreInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetStoreInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetBucketInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetBucketInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetStreamSetInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetStreamSetInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetStreamInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetStreamInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetStream_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetStream_reflection_ = NULL;
const ::google::protobuf::Descriptor* WriteEnvelope_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WriteEnvelope_reflection_ = NULL;
const ::google::protobuf::Descriptor* WriteEnvelopeFromMessages_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WriteEnvelopeFromMessages_reflection_ = NULL;
const ::google::protobuf::Descriptor* SubscribeStoreChanges_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubscribeStoreChanges_reflection_ = NULL;
const ::google::protobuf::Descriptor* SubscribeEnvelopes_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubscribeEnvelopes_reflection_ = NULL;
const ::google::protobuf::Descriptor* SubscribeKeepalive_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubscribeKeepalive_reflection_ = NULL;
const ::google::protobuf::Descriptor* SubscribeCancel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubscribeCancel_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_zippylog_2fprotocol_2frequest_2eproto() {
  protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "zippylog/protocol/request.proto");
  GOOGLE_CHECK(file != NULL);
  GetFeatures_descriptor_ = file->message_type(0);
  static const int GetFeatures_offsets_[1] = {
  };
  GetFeatures_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetFeatures_descriptor_,
      GetFeatures::default_instance_,
      GetFeatures_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetFeatures, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetFeatures, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetFeatures));
  GetStoreInfo_descriptor_ = file->message_type(1);
  static const int GetStoreInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStoreInfo, version_),
  };
  GetStoreInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetStoreInfo_descriptor_,
      GetStoreInfo::default_instance_,
      GetStoreInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStoreInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStoreInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetStoreInfo));
  GetBucketInfo_descriptor_ = file->message_type(2);
  static const int GetBucketInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBucketInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBucketInfo, path_),
  };
  GetBucketInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetBucketInfo_descriptor_,
      GetBucketInfo::default_instance_,
      GetBucketInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBucketInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBucketInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetBucketInfo));
  GetStreamSetInfo_descriptor_ = file->message_type(3);
  static const int GetStreamSetInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStreamSetInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStreamSetInfo, path_),
  };
  GetStreamSetInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetStreamSetInfo_descriptor_,
      GetStreamSetInfo::default_instance_,
      GetStreamSetInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStreamSetInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStreamSetInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetStreamSetInfo));
  GetStreamInfo_descriptor_ = file->message_type(4);
  static const int GetStreamInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStreamInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStreamInfo, path_),
  };
  GetStreamInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetStreamInfo_descriptor_,
      GetStreamInfo::default_instance_,
      GetStreamInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStreamInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStreamInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetStreamInfo));
  GetStream_descriptor_ = file->message_type(5);
  static const int GetStream_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStream, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStream, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStream, start_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStream, max_response_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStream, max_response_envelopes_),
  };
  GetStream_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetStream_descriptor_,
      GetStream::default_instance_,
      GetStream_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStream, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetStream, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetStream));
  WriteEnvelope_descriptor_ = file->message_type(6);
  static const int WriteEnvelope_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteEnvelope, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteEnvelope, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteEnvelope, envelope_),
  };
  WriteEnvelope_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WriteEnvelope_descriptor_,
      WriteEnvelope::default_instance_,
      WriteEnvelope_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteEnvelope, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteEnvelope, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WriteEnvelope));
  WriteEnvelopeFromMessages_descriptor_ = file->message_type(7);
  static const int WriteEnvelopeFromMessages_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteEnvelopeFromMessages, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteEnvelopeFromMessages, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteEnvelopeFromMessages, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteEnvelopeFromMessages, message_namespace_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteEnvelopeFromMessages, message_type_),
  };
  WriteEnvelopeFromMessages_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WriteEnvelopeFromMessages_descriptor_,
      WriteEnvelopeFromMessages::default_instance_,
      WriteEnvelopeFromMessages_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteEnvelopeFromMessages, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteEnvelopeFromMessages, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WriteEnvelopeFromMessages));
  SubscribeStoreChanges_descriptor_ = file->message_type(8);
  static const int SubscribeStoreChanges_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeStoreChanges, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeStoreChanges, path_),
  };
  SubscribeStoreChanges_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SubscribeStoreChanges_descriptor_,
      SubscribeStoreChanges::default_instance_,
      SubscribeStoreChanges_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeStoreChanges, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeStoreChanges, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SubscribeStoreChanges));
  SubscribeEnvelopes_descriptor_ = file->message_type(9);
  static const int SubscribeEnvelopes_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeEnvelopes, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeEnvelopes, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeEnvelopes, lua_code_),
  };
  SubscribeEnvelopes_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SubscribeEnvelopes_descriptor_,
      SubscribeEnvelopes::default_instance_,
      SubscribeEnvelopes_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeEnvelopes, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeEnvelopes, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SubscribeEnvelopes));
  SubscribeKeepalive_descriptor_ = file->message_type(10);
  static const int SubscribeKeepalive_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeKeepalive, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeKeepalive, id_),
  };
  SubscribeKeepalive_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SubscribeKeepalive_descriptor_,
      SubscribeKeepalive::default_instance_,
      SubscribeKeepalive_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeKeepalive, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeKeepalive, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SubscribeKeepalive));
  SubscribeCancel_descriptor_ = file->message_type(11);
  static const int SubscribeCancel_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeCancel, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeCancel, id_),
  };
  SubscribeCancel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SubscribeCancel_descriptor_,
      SubscribeCancel::default_instance_,
      SubscribeCancel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeCancel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeCancel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SubscribeCancel));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_zippylog_2fprotocol_2frequest_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetFeatures_descriptor_, &GetFeatures::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetStoreInfo_descriptor_, &GetStoreInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetBucketInfo_descriptor_, &GetBucketInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetStreamSetInfo_descriptor_, &GetStreamSetInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetStreamInfo_descriptor_, &GetStreamInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetStream_descriptor_, &GetStream::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WriteEnvelope_descriptor_, &WriteEnvelope::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WriteEnvelopeFromMessages_descriptor_, &WriteEnvelopeFromMessages::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SubscribeStoreChanges_descriptor_, &SubscribeStoreChanges::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SubscribeEnvelopes_descriptor_, &SubscribeEnvelopes::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SubscribeKeepalive_descriptor_, &SubscribeKeepalive::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SubscribeCancel_descriptor_, &SubscribeCancel::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_zippylog_2fprotocol_2frequest_2eproto() {
  delete GetFeatures::default_instance_;
  delete GetFeatures_reflection_;
  delete GetStoreInfo::default_instance_;
  delete GetStoreInfo_reflection_;
  delete GetBucketInfo::default_instance_;
  delete GetBucketInfo_reflection_;
  delete GetStreamSetInfo::default_instance_;
  delete GetStreamSetInfo_reflection_;
  delete GetStreamInfo::default_instance_;
  delete GetStreamInfo_reflection_;
  delete GetStream::default_instance_;
  delete GetStream_reflection_;
  delete WriteEnvelope::default_instance_;
  delete WriteEnvelope_reflection_;
  delete WriteEnvelopeFromMessages::default_instance_;
  delete WriteEnvelopeFromMessages_reflection_;
  delete SubscribeStoreChanges::default_instance_;
  delete SubscribeStoreChanges_reflection_;
  delete SubscribeEnvelopes::default_instance_;
  delete SubscribeEnvelopes_reflection_;
  delete SubscribeKeepalive::default_instance_;
  delete SubscribeKeepalive_reflection_;
  delete SubscribeCancel::default_instance_;
  delete SubscribeCancel_reflection_;
}

void protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\037zippylog/protocol/request.proto\022\031zippy"
    "log.protocol.request\"\r\n\013GetFeatures\"\037\n\014G"
    "etStoreInfo\022\017\n\007version\030\001 \002(\r\".\n\rGetBucke"
    "tInfo\022\017\n\007version\030\001 \002(\r\022\014\n\004path\030\002 \001(\t\"1\n\020"
    "GetStreamSetInfo\022\017\n\007version\030\001 \002(\r\022\014\n\004pat"
    "h\030\002 \001(\t\".\n\rGetStreamInfo\022\017\n\007version\030\001 \002("
    "\r\022\014\n\004path\030\002 \001(\t\"|\n\tGetStream\022\017\n\007version\030"
    "\001 \002(\r\022\014\n\004path\030\002 \001(\t\022\024\n\014start_offset\030\003 \001("
    "\004\022\032\n\022max_response_bytes\030\004 \001(\r\022\036\n\026max_res"
    "ponse_envelopes\030\005 \001(\r\"@\n\rWriteEnvelope\022\017"
    "\n\007version\030\001 \002(\r\022\014\n\004path\030\002 \001(\t\022\020\n\010envelop"
    "e\030\003 \003(\014\"\204\001\n\031WriteEnvelopeFromMessages\022\017\n"
    "\007version\030\001 \002(\r\022\014\n\004path\030\002 \001(\t\022\017\n\007message\030"
    "\003 \003(\014\022\035\n\021message_namespace\030\004 \003(\rB\002\020\001\022\030\n\014"
    "message_type\030\005 \003(\rB\002\020\001\"6\n\025SubscribeStore"
    "Changes\022\017\n\007version\030\001 \002(\r\022\014\n\004path\030\002 \003(\t\"E"
    "\n\022SubscribeEnvelopes\022\017\n\007version\030\001 \002(\r\022\014\n"
    "\004path\030\002 \003(\t\022\020\n\010lua_code\030\003 \001(\t\"1\n\022Subscri"
    "beKeepalive\022\017\n\007version\030\001 \002(\r\022\n\n\002id\030\002 \001(\014"
    "\".\n\017SubscribeCancel\022\017\n\007version\030\001 \002(\r\022\n\n\002"
    "id\030\002 \001(\014", 808);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "zippylog/protocol/request.proto", &protobuf_RegisterTypes);
  GetFeatures::default_instance_ = new GetFeatures();
  GetStoreInfo::default_instance_ = new GetStoreInfo();
  GetBucketInfo::default_instance_ = new GetBucketInfo();
  GetStreamSetInfo::default_instance_ = new GetStreamSetInfo();
  GetStreamInfo::default_instance_ = new GetStreamInfo();
  GetStream::default_instance_ = new GetStream();
  WriteEnvelope::default_instance_ = new WriteEnvelope();
  WriteEnvelopeFromMessages::default_instance_ = new WriteEnvelopeFromMessages();
  SubscribeStoreChanges::default_instance_ = new SubscribeStoreChanges();
  SubscribeEnvelopes::default_instance_ = new SubscribeEnvelopes();
  SubscribeKeepalive::default_instance_ = new SubscribeKeepalive();
  SubscribeCancel::default_instance_ = new SubscribeCancel();
  GetFeatures::default_instance_->InitAsDefaultInstance();
  GetStoreInfo::default_instance_->InitAsDefaultInstance();
  GetBucketInfo::default_instance_->InitAsDefaultInstance();
  GetStreamSetInfo::default_instance_->InitAsDefaultInstance();
  GetStreamInfo::default_instance_->InitAsDefaultInstance();
  GetStream::default_instance_->InitAsDefaultInstance();
  WriteEnvelope::default_instance_->InitAsDefaultInstance();
  WriteEnvelopeFromMessages::default_instance_->InitAsDefaultInstance();
  SubscribeStoreChanges::default_instance_->InitAsDefaultInstance();
  SubscribeEnvelopes::default_instance_->InitAsDefaultInstance();
  SubscribeKeepalive::default_instance_->InitAsDefaultInstance();
  SubscribeCancel::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_zippylog_2fprotocol_2frequest_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_zippylog_2fprotocol_2frequest_2eproto {
  StaticDescriptorInitializer_zippylog_2fprotocol_2frequest_2eproto() {
    protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();
  }
} static_descriptor_initializer_zippylog_2fprotocol_2frequest_2eproto_;


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GetFeatures::GetFeatures()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetFeatures::InitAsDefaultInstance() {
}

GetFeatures::GetFeatures(const GetFeatures& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetFeatures::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetFeatures::~GetFeatures() {
  SharedDtor();
}

void GetFeatures::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetFeatures::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetFeatures::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetFeatures_descriptor_;
}

const GetFeatures& GetFeatures::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();  return *default_instance_;
}

GetFeatures* GetFeatures::default_instance_ = NULL;

GetFeatures* GetFeatures::New() const {
  return new GetFeatures;
}

void GetFeatures::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetFeatures::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void GetFeatures::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetFeatures::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetFeatures::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetFeatures::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetFeatures* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetFeatures*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetFeatures::MergeFrom(const GetFeatures& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetFeatures::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetFeatures::CopyFrom(const GetFeatures& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetFeatures::IsInitialized() const {
  
  return true;
}

void GetFeatures::Swap(GetFeatures* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetFeatures::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetFeatures_descriptor_;
  metadata.reflection = GetFeatures_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetStoreInfo::kVersionFieldNumber;
#endif  // !_MSC_VER

GetStoreInfo::GetStoreInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetStoreInfo::InitAsDefaultInstance() {
}

GetStoreInfo::GetStoreInfo(const GetStoreInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetStoreInfo::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetStoreInfo::~GetStoreInfo() {
  SharedDtor();
}

void GetStoreInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetStoreInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetStoreInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetStoreInfo_descriptor_;
}

const GetStoreInfo& GetStoreInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();  return *default_instance_;
}

GetStoreInfo* GetStoreInfo::default_instance_ = NULL;

GetStoreInfo* GetStoreInfo::New() const {
  return new GetStoreInfo;
}

void GetStoreInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetStoreInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetStoreInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetStoreInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetStoreInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetStoreInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetStoreInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetStoreInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetStoreInfo::MergeFrom(const GetStoreInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetStoreInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetStoreInfo::CopyFrom(const GetStoreInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetStoreInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GetStoreInfo::Swap(GetStoreInfo* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetStoreInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetStoreInfo_descriptor_;
  metadata.reflection = GetStoreInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string GetBucketInfo::_default_path_;
#ifndef _MSC_VER
const int GetBucketInfo::kVersionFieldNumber;
const int GetBucketInfo::kPathFieldNumber;
#endif  // !_MSC_VER

GetBucketInfo::GetBucketInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetBucketInfo::InitAsDefaultInstance() {
}

GetBucketInfo::GetBucketInfo(const GetBucketInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetBucketInfo::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  path_ = const_cast< ::std::string*>(&_default_path_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetBucketInfo::~GetBucketInfo() {
  SharedDtor();
}

void GetBucketInfo::SharedDtor() {
  if (path_ != &_default_path_) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void GetBucketInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetBucketInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetBucketInfo_descriptor_;
}

const GetBucketInfo& GetBucketInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();  return *default_instance_;
}

GetBucketInfo* GetBucketInfo::default_instance_ = NULL;

GetBucketInfo* GetBucketInfo::New() const {
  return new GetBucketInfo;
}

void GetBucketInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    if (_has_bit(1)) {
      if (path_ != &_default_path_) {
        path_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetBucketInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }
      
      // optional string path = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetBucketInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }
  
  // optional string path = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->path(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetBucketInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }
  
  // optional string path = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetBucketInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
    // optional string path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetBucketInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetBucketInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetBucketInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetBucketInfo::MergeFrom(const GetBucketInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
    if (from._has_bit(1)) {
      set_path(from.path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetBucketInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetBucketInfo::CopyFrom(const GetBucketInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetBucketInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GetBucketInfo::Swap(GetBucketInfo* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(path_, other->path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetBucketInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetBucketInfo_descriptor_;
  metadata.reflection = GetBucketInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string GetStreamSetInfo::_default_path_;
#ifndef _MSC_VER
const int GetStreamSetInfo::kVersionFieldNumber;
const int GetStreamSetInfo::kPathFieldNumber;
#endif  // !_MSC_VER

GetStreamSetInfo::GetStreamSetInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetStreamSetInfo::InitAsDefaultInstance() {
}

GetStreamSetInfo::GetStreamSetInfo(const GetStreamSetInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetStreamSetInfo::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  path_ = const_cast< ::std::string*>(&_default_path_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetStreamSetInfo::~GetStreamSetInfo() {
  SharedDtor();
}

void GetStreamSetInfo::SharedDtor() {
  if (path_ != &_default_path_) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void GetStreamSetInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetStreamSetInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetStreamSetInfo_descriptor_;
}

const GetStreamSetInfo& GetStreamSetInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();  return *default_instance_;
}

GetStreamSetInfo* GetStreamSetInfo::default_instance_ = NULL;

GetStreamSetInfo* GetStreamSetInfo::New() const {
  return new GetStreamSetInfo;
}

void GetStreamSetInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    if (_has_bit(1)) {
      if (path_ != &_default_path_) {
        path_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetStreamSetInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }
      
      // optional string path = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetStreamSetInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }
  
  // optional string path = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->path(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetStreamSetInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }
  
  // optional string path = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetStreamSetInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
    // optional string path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetStreamSetInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetStreamSetInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetStreamSetInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetStreamSetInfo::MergeFrom(const GetStreamSetInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
    if (from._has_bit(1)) {
      set_path(from.path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetStreamSetInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetStreamSetInfo::CopyFrom(const GetStreamSetInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetStreamSetInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GetStreamSetInfo::Swap(GetStreamSetInfo* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(path_, other->path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetStreamSetInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetStreamSetInfo_descriptor_;
  metadata.reflection = GetStreamSetInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string GetStreamInfo::_default_path_;
#ifndef _MSC_VER
const int GetStreamInfo::kVersionFieldNumber;
const int GetStreamInfo::kPathFieldNumber;
#endif  // !_MSC_VER

GetStreamInfo::GetStreamInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetStreamInfo::InitAsDefaultInstance() {
}

GetStreamInfo::GetStreamInfo(const GetStreamInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetStreamInfo::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  path_ = const_cast< ::std::string*>(&_default_path_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetStreamInfo::~GetStreamInfo() {
  SharedDtor();
}

void GetStreamInfo::SharedDtor() {
  if (path_ != &_default_path_) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void GetStreamInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetStreamInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetStreamInfo_descriptor_;
}

const GetStreamInfo& GetStreamInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();  return *default_instance_;
}

GetStreamInfo* GetStreamInfo::default_instance_ = NULL;

GetStreamInfo* GetStreamInfo::New() const {
  return new GetStreamInfo;
}

void GetStreamInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    if (_has_bit(1)) {
      if (path_ != &_default_path_) {
        path_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetStreamInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }
      
      // optional string path = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetStreamInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }
  
  // optional string path = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->path(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetStreamInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }
  
  // optional string path = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetStreamInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
    // optional string path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetStreamInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetStreamInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetStreamInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetStreamInfo::MergeFrom(const GetStreamInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
    if (from._has_bit(1)) {
      set_path(from.path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetStreamInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetStreamInfo::CopyFrom(const GetStreamInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetStreamInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GetStreamInfo::Swap(GetStreamInfo* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(path_, other->path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetStreamInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetStreamInfo_descriptor_;
  metadata.reflection = GetStreamInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string GetStream::_default_path_;
#ifndef _MSC_VER
const int GetStream::kVersionFieldNumber;
const int GetStream::kPathFieldNumber;
const int GetStream::kStartOffsetFieldNumber;
const int GetStream::kMaxResponseBytesFieldNumber;
const int GetStream::kMaxResponseEnvelopesFieldNumber;
#endif  // !_MSC_VER

GetStream::GetStream()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetStream::InitAsDefaultInstance() {
}

GetStream::GetStream(const GetStream& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetStream::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  path_ = const_cast< ::std::string*>(&_default_path_);
  start_offset_ = GOOGLE_ULONGLONG(0);
  max_response_bytes_ = 0u;
  max_response_envelopes_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetStream::~GetStream() {
  SharedDtor();
}

void GetStream::SharedDtor() {
  if (path_ != &_default_path_) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void GetStream::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetStream::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetStream_descriptor_;
}

const GetStream& GetStream::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();  return *default_instance_;
}

GetStream* GetStream::default_instance_ = NULL;

GetStream* GetStream::New() const {
  return new GetStream;
}

void GetStream::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    if (_has_bit(1)) {
      if (path_ != &_default_path_) {
        path_->clear();
      }
    }
    start_offset_ = GOOGLE_ULONGLONG(0);
    max_response_bytes_ = 0u;
    max_response_envelopes_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetStream::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }
      
      // optional string path = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_start_offset;
        break;
      }
      
      // optional uint64 start_offset = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_start_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &start_offset_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_max_response_bytes;
        break;
      }
      
      // optional uint32 max_response_bytes = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_response_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_response_bytes_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_max_response_envelopes;
        break;
      }
      
      // optional uint32 max_response_envelopes = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_response_envelopes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_response_envelopes_)));
          _set_bit(4);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetStream::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }
  
  // optional string path = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->path(), output);
  }
  
  // optional uint64 start_offset = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->start_offset(), output);
  }
  
  // optional uint32 max_response_bytes = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->max_response_bytes(), output);
  }
  
  // optional uint32 max_response_envelopes = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->max_response_envelopes(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetStream::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }
  
  // optional string path = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path(), target);
  }
  
  // optional uint64 start_offset = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->start_offset(), target);
  }
  
  // optional uint32 max_response_bytes = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->max_response_bytes(), target);
  }
  
  // optional uint32 max_response_envelopes = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->max_response_envelopes(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetStream::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
    // optional string path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
    // optional uint64 start_offset = 3;
    if (has_start_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->start_offset());
    }
    
    // optional uint32 max_response_bytes = 4;
    if (has_max_response_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_response_bytes());
    }
    
    // optional uint32 max_response_envelopes = 5;
    if (has_max_response_envelopes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_response_envelopes());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetStream::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetStream* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetStream*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetStream::MergeFrom(const GetStream& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
    if (from._has_bit(1)) {
      set_path(from.path());
    }
    if (from._has_bit(2)) {
      set_start_offset(from.start_offset());
    }
    if (from._has_bit(3)) {
      set_max_response_bytes(from.max_response_bytes());
    }
    if (from._has_bit(4)) {
      set_max_response_envelopes(from.max_response_envelopes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetStream::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetStream::CopyFrom(const GetStream& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetStream::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GetStream::Swap(GetStream* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(path_, other->path_);
    std::swap(start_offset_, other->start_offset_);
    std::swap(max_response_bytes_, other->max_response_bytes_);
    std::swap(max_response_envelopes_, other->max_response_envelopes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetStream::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetStream_descriptor_;
  metadata.reflection = GetStream_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string WriteEnvelope::_default_path_;
#ifndef _MSC_VER
const int WriteEnvelope::kVersionFieldNumber;
const int WriteEnvelope::kPathFieldNumber;
const int WriteEnvelope::kEnvelopeFieldNumber;
#endif  // !_MSC_VER

WriteEnvelope::WriteEnvelope()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WriteEnvelope::InitAsDefaultInstance() {
}

WriteEnvelope::WriteEnvelope(const WriteEnvelope& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WriteEnvelope::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  path_ = const_cast< ::std::string*>(&_default_path_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WriteEnvelope::~WriteEnvelope() {
  SharedDtor();
}

void WriteEnvelope::SharedDtor() {
  if (path_ != &_default_path_) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void WriteEnvelope::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WriteEnvelope::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WriteEnvelope_descriptor_;
}

const WriteEnvelope& WriteEnvelope::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();  return *default_instance_;
}

WriteEnvelope* WriteEnvelope::default_instance_ = NULL;

WriteEnvelope* WriteEnvelope::New() const {
  return new WriteEnvelope;
}

void WriteEnvelope::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    if (_has_bit(1)) {
      if (path_ != &_default_path_) {
        path_->clear();
      }
    }
  }
  envelope_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WriteEnvelope::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }
      
      // optional string path = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_envelope;
        break;
      }
      
      // repeated bytes envelope = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_envelope:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_envelope()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_envelope;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WriteEnvelope::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }
  
  // optional string path = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->path(), output);
  }
  
  // repeated bytes envelope = 3;
  for (int i = 0; i < this->envelope_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->envelope(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WriteEnvelope::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }
  
  // optional string path = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path(), target);
  }
  
  // repeated bytes envelope = 3;
  for (int i = 0; i < this->envelope_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(3, this->envelope(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WriteEnvelope::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
    // optional string path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
  }
  // repeated bytes envelope = 3;
  total_size += 1 * this->envelope_size();
  for (int i = 0; i < this->envelope_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->envelope(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WriteEnvelope::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WriteEnvelope* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WriteEnvelope*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WriteEnvelope::MergeFrom(const WriteEnvelope& from) {
  GOOGLE_CHECK_NE(&from, this);
  envelope_.MergeFrom(from.envelope_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
    if (from._has_bit(1)) {
      set_path(from.path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WriteEnvelope::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WriteEnvelope::CopyFrom(const WriteEnvelope& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteEnvelope::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void WriteEnvelope::Swap(WriteEnvelope* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(path_, other->path_);
    envelope_.Swap(&other->envelope_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WriteEnvelope::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WriteEnvelope_descriptor_;
  metadata.reflection = WriteEnvelope_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string WriteEnvelopeFromMessages::_default_path_;
#ifndef _MSC_VER
const int WriteEnvelopeFromMessages::kVersionFieldNumber;
const int WriteEnvelopeFromMessages::kPathFieldNumber;
const int WriteEnvelopeFromMessages::kMessageFieldNumber;
const int WriteEnvelopeFromMessages::kMessageNamespaceFieldNumber;
const int WriteEnvelopeFromMessages::kMessageTypeFieldNumber;
#endif  // !_MSC_VER

WriteEnvelopeFromMessages::WriteEnvelopeFromMessages()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WriteEnvelopeFromMessages::InitAsDefaultInstance() {
}

WriteEnvelopeFromMessages::WriteEnvelopeFromMessages(const WriteEnvelopeFromMessages& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WriteEnvelopeFromMessages::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  path_ = const_cast< ::std::string*>(&_default_path_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WriteEnvelopeFromMessages::~WriteEnvelopeFromMessages() {
  SharedDtor();
}

void WriteEnvelopeFromMessages::SharedDtor() {
  if (path_ != &_default_path_) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void WriteEnvelopeFromMessages::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WriteEnvelopeFromMessages::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WriteEnvelopeFromMessages_descriptor_;
}

const WriteEnvelopeFromMessages& WriteEnvelopeFromMessages::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();  return *default_instance_;
}

WriteEnvelopeFromMessages* WriteEnvelopeFromMessages::default_instance_ = NULL;

WriteEnvelopeFromMessages* WriteEnvelopeFromMessages::New() const {
  return new WriteEnvelopeFromMessages;
}

void WriteEnvelopeFromMessages::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    if (_has_bit(1)) {
      if (path_ != &_default_path_) {
        path_->clear();
      }
    }
  }
  message_.Clear();
  message_namespace_.Clear();
  message_type_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WriteEnvelopeFromMessages::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }
      
      // optional string path = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_message;
        break;
      }
      
      // repeated bytes message = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_message;
        if (input->ExpectTag(34)) goto parse_message_namespace;
        break;
      }
      
      // repeated uint32 message_namespace = 4 [packed = true];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message_namespace:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_message_namespace())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 34, input, this->mutable_message_namespace())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_message_type;
        break;
      }
      
      // repeated uint32 message_type = 5 [packed = true];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_message_type())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 42, input, this->mutable_message_type())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WriteEnvelopeFromMessages::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }
  
  // optional string path = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->path(), output);
  }
  
  // repeated bytes message = 3;
  for (int i = 0; i < this->message_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->message(i), output);
  }
  
  // repeated uint32 message_namespace = 4 [packed = true];
  if (this->message_namespace_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(4, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_message_namespace_cached_byte_size_);
  }
  for (int i = 0; i < this->message_namespace_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->message_namespace(i), output);
  }
  
  // repeated uint32 message_type = 5 [packed = true];
  if (this->message_type_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(5, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_message_type_cached_byte_size_);
  }
  for (int i = 0; i < this->message_type_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->message_type(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WriteEnvelopeFromMessages::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }
  
  // optional string path = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path(), target);
  }
  
  // repeated bytes message = 3;
  for (int i = 0; i < this->message_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(3, this->message(i), target);
  }
  
  // repeated uint32 message_namespace = 4 [packed = true];
  if (this->message_namespace_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      4,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _message_namespace_cached_byte_size_, target);
  }
  for (int i = 0; i < this->message_namespace_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->message_namespace(i), target);
  }
  
  // repeated uint32 message_type = 5 [packed = true];
  if (this->message_type_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      5,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _message_type_cached_byte_size_, target);
  }
  for (int i = 0; i < this->message_type_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->message_type(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WriteEnvelopeFromMessages::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
    // optional string path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
  }
  // repeated bytes message = 3;
  total_size += 1 * this->message_size();
  for (int i = 0; i < this->message_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->message(i));
  }
  
  // repeated uint32 message_namespace = 4 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->message_namespace_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->message_namespace(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _message_namespace_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated uint32 message_type = 5 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->message_type_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->message_type(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _message_type_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WriteEnvelopeFromMessages::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WriteEnvelopeFromMessages* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WriteEnvelopeFromMessages*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WriteEnvelopeFromMessages::MergeFrom(const WriteEnvelopeFromMessages& from) {
  GOOGLE_CHECK_NE(&from, this);
  message_.MergeFrom(from.message_);
  message_namespace_.MergeFrom(from.message_namespace_);
  message_type_.MergeFrom(from.message_type_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
    if (from._has_bit(1)) {
      set_path(from.path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WriteEnvelopeFromMessages::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WriteEnvelopeFromMessages::CopyFrom(const WriteEnvelopeFromMessages& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteEnvelopeFromMessages::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void WriteEnvelopeFromMessages::Swap(WriteEnvelopeFromMessages* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(path_, other->path_);
    message_.Swap(&other->message_);
    message_namespace_.Swap(&other->message_namespace_);
    message_type_.Swap(&other->message_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WriteEnvelopeFromMessages::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WriteEnvelopeFromMessages_descriptor_;
  metadata.reflection = WriteEnvelopeFromMessages_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SubscribeStoreChanges::kVersionFieldNumber;
const int SubscribeStoreChanges::kPathFieldNumber;
#endif  // !_MSC_VER

SubscribeStoreChanges::SubscribeStoreChanges()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SubscribeStoreChanges::InitAsDefaultInstance() {
}

SubscribeStoreChanges::SubscribeStoreChanges(const SubscribeStoreChanges& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SubscribeStoreChanges::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubscribeStoreChanges::~SubscribeStoreChanges() {
  SharedDtor();
}

void SubscribeStoreChanges::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SubscribeStoreChanges::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubscribeStoreChanges::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubscribeStoreChanges_descriptor_;
}

const SubscribeStoreChanges& SubscribeStoreChanges::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();  return *default_instance_;
}

SubscribeStoreChanges* SubscribeStoreChanges::default_instance_ = NULL;

SubscribeStoreChanges* SubscribeStoreChanges::New() const {
  return new SubscribeStoreChanges;
}

void SubscribeStoreChanges::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
  }
  path_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SubscribeStoreChanges::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }
      
      // repeated string path = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path(0).data(), this->path(0).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_path;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SubscribeStoreChanges::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }
  
  // repeated string path = 2;
  for (int i = 0; i < this->path_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->path(i).data(), this->path(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->path(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SubscribeStoreChanges::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }
  
  // repeated string path = 2;
  for (int i = 0; i < this->path_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path(i).data(), this->path(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->path(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SubscribeStoreChanges::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
  }
  // repeated string path = 2;
  total_size += 1 * this->path_size();
  for (int i = 0; i < this->path_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->path(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubscribeStoreChanges::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SubscribeStoreChanges* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SubscribeStoreChanges*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SubscribeStoreChanges::MergeFrom(const SubscribeStoreChanges& from) {
  GOOGLE_CHECK_NE(&from, this);
  path_.MergeFrom(from.path_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SubscribeStoreChanges::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubscribeStoreChanges::CopyFrom(const SubscribeStoreChanges& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeStoreChanges::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void SubscribeStoreChanges::Swap(SubscribeStoreChanges* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    path_.Swap(&other->path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SubscribeStoreChanges::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubscribeStoreChanges_descriptor_;
  metadata.reflection = SubscribeStoreChanges_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string SubscribeEnvelopes::_default_lua_code_;
#ifndef _MSC_VER
const int SubscribeEnvelopes::kVersionFieldNumber;
const int SubscribeEnvelopes::kPathFieldNumber;
const int SubscribeEnvelopes::kLuaCodeFieldNumber;
#endif  // !_MSC_VER

SubscribeEnvelopes::SubscribeEnvelopes()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SubscribeEnvelopes::InitAsDefaultInstance() {
}

SubscribeEnvelopes::SubscribeEnvelopes(const SubscribeEnvelopes& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SubscribeEnvelopes::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  lua_code_ = const_cast< ::std::string*>(&_default_lua_code_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubscribeEnvelopes::~SubscribeEnvelopes() {
  SharedDtor();
}

void SubscribeEnvelopes::SharedDtor() {
  if (lua_code_ != &_default_lua_code_) {
    delete lua_code_;
  }
  if (this != default_instance_) {
  }
}

void SubscribeEnvelopes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubscribeEnvelopes::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubscribeEnvelopes_descriptor_;
}

const SubscribeEnvelopes& SubscribeEnvelopes::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();  return *default_instance_;
}

SubscribeEnvelopes* SubscribeEnvelopes::default_instance_ = NULL;

SubscribeEnvelopes* SubscribeEnvelopes::New() const {
  return new SubscribeEnvelopes;
}

void SubscribeEnvelopes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    if (_has_bit(2)) {
      if (lua_code_ != &_default_lua_code_) {
        lua_code_->clear();
      }
    }
  }
  path_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SubscribeEnvelopes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }
      
      // repeated string path = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path(0).data(), this->path(0).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_path;
        if (input->ExpectTag(26)) goto parse_lua_code;
        break;
      }
      
      // optional string lua_code = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lua_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_lua_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->lua_code().data(), this->lua_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SubscribeEnvelopes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }
  
  // repeated string path = 2;
  for (int i = 0; i < this->path_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->path(i).data(), this->path(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->path(i), output);
  }
  
  // optional string lua_code = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->lua_code().data(), this->lua_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->lua_code(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SubscribeEnvelopes::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }
  
  // repeated string path = 2;
  for (int i = 0; i < this->path_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path(i).data(), this->path(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->path(i), target);
  }
  
  // optional string lua_code = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->lua_code().data(), this->lua_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->lua_code(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SubscribeEnvelopes::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
    // optional string lua_code = 3;
    if (has_lua_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->lua_code());
    }
    
  }
  // repeated string path = 2;
  total_size += 1 * this->path_size();
  for (int i = 0; i < this->path_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->path(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubscribeEnvelopes::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SubscribeEnvelopes* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SubscribeEnvelopes*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SubscribeEnvelopes::MergeFrom(const SubscribeEnvelopes& from) {
  GOOGLE_CHECK_NE(&from, this);
  path_.MergeFrom(from.path_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
    if (from._has_bit(2)) {
      set_lua_code(from.lua_code());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SubscribeEnvelopes::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubscribeEnvelopes::CopyFrom(const SubscribeEnvelopes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeEnvelopes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void SubscribeEnvelopes::Swap(SubscribeEnvelopes* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    path_.Swap(&other->path_);
    std::swap(lua_code_, other->lua_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SubscribeEnvelopes::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubscribeEnvelopes_descriptor_;
  metadata.reflection = SubscribeEnvelopes_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string SubscribeKeepalive::_default_id_;
#ifndef _MSC_VER
const int SubscribeKeepalive::kVersionFieldNumber;
const int SubscribeKeepalive::kIdFieldNumber;
#endif  // !_MSC_VER

SubscribeKeepalive::SubscribeKeepalive()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SubscribeKeepalive::InitAsDefaultInstance() {
}

SubscribeKeepalive::SubscribeKeepalive(const SubscribeKeepalive& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SubscribeKeepalive::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  id_ = const_cast< ::std::string*>(&_default_id_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubscribeKeepalive::~SubscribeKeepalive() {
  SharedDtor();
}

void SubscribeKeepalive::SharedDtor() {
  if (id_ != &_default_id_) {
    delete id_;
  }
  if (this != default_instance_) {
  }
}

void SubscribeKeepalive::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubscribeKeepalive::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubscribeKeepalive_descriptor_;
}

const SubscribeKeepalive& SubscribeKeepalive::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();  return *default_instance_;
}

SubscribeKeepalive* SubscribeKeepalive::default_instance_ = NULL;

SubscribeKeepalive* SubscribeKeepalive::New() const {
  return new SubscribeKeepalive;
}

void SubscribeKeepalive::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    if (_has_bit(1)) {
      if (id_ != &_default_id_) {
        id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SubscribeKeepalive::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_id;
        break;
      }
      
      // optional bytes id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SubscribeKeepalive::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }
  
  // optional bytes id = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SubscribeKeepalive::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }
  
  // optional bytes id = 2;
  if (_has_bit(1)) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SubscribeKeepalive::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
    // optional bytes id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubscribeKeepalive::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SubscribeKeepalive* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SubscribeKeepalive*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SubscribeKeepalive::MergeFrom(const SubscribeKeepalive& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
    if (from._has_bit(1)) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SubscribeKeepalive::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubscribeKeepalive::CopyFrom(const SubscribeKeepalive& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeKeepalive::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void SubscribeKeepalive::Swap(SubscribeKeepalive* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SubscribeKeepalive::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubscribeKeepalive_descriptor_;
  metadata.reflection = SubscribeKeepalive_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string SubscribeCancel::_default_id_;
#ifndef _MSC_VER
const int SubscribeCancel::kVersionFieldNumber;
const int SubscribeCancel::kIdFieldNumber;
#endif  // !_MSC_VER

SubscribeCancel::SubscribeCancel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SubscribeCancel::InitAsDefaultInstance() {
}

SubscribeCancel::SubscribeCancel(const SubscribeCancel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SubscribeCancel::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  id_ = const_cast< ::std::string*>(&_default_id_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubscribeCancel::~SubscribeCancel() {
  SharedDtor();
}

void SubscribeCancel::SharedDtor() {
  if (id_ != &_default_id_) {
    delete id_;
  }
  if (this != default_instance_) {
  }
}

void SubscribeCancel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubscribeCancel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubscribeCancel_descriptor_;
}

const SubscribeCancel& SubscribeCancel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zippylog_2fprotocol_2frequest_2eproto();  return *default_instance_;
}

SubscribeCancel* SubscribeCancel::default_instance_ = NULL;

SubscribeCancel* SubscribeCancel::New() const {
  return new SubscribeCancel;
}

void SubscribeCancel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    if (_has_bit(1)) {
      if (id_ != &_default_id_) {
        id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SubscribeCancel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_id;
        break;
      }
      
      // optional bytes id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SubscribeCancel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }
  
  // optional bytes id = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SubscribeCancel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }
  
  // optional bytes id = 2;
  if (_has_bit(1)) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SubscribeCancel::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
    // optional bytes id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubscribeCancel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SubscribeCancel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SubscribeCancel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SubscribeCancel::MergeFrom(const SubscribeCancel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
    if (from._has_bit(1)) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SubscribeCancel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubscribeCancel::CopyFrom(const SubscribeCancel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeCancel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void SubscribeCancel::Swap(SubscribeCancel* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SubscribeCancel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubscribeCancel_descriptor_;
  metadata.reflection = SubscribeCancel_reflection_;
  return metadata;
}



bool GetFeatures::add_to_envelope(::zippylog::Envelope *envelope) {
    return envelope->AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool GetFeatures::add_to_envelope(::zippylog::Envelope &envelope) {
    return envelope.AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool GetStoreInfo::add_to_envelope(::zippylog::Envelope *envelope) {
    return envelope->AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool GetStoreInfo::add_to_envelope(::zippylog::Envelope &envelope) {
    return envelope.AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool GetBucketInfo::add_to_envelope(::zippylog::Envelope *envelope) {
    return envelope->AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool GetBucketInfo::add_to_envelope(::zippylog::Envelope &envelope) {
    return envelope.AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool GetStreamSetInfo::add_to_envelope(::zippylog::Envelope *envelope) {
    return envelope->AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool GetStreamSetInfo::add_to_envelope(::zippylog::Envelope &envelope) {
    return envelope.AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool GetStreamInfo::add_to_envelope(::zippylog::Envelope *envelope) {
    return envelope->AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool GetStreamInfo::add_to_envelope(::zippylog::Envelope &envelope) {
    return envelope.AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool GetStream::add_to_envelope(::zippylog::Envelope *envelope) {
    return envelope->AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool GetStream::add_to_envelope(::zippylog::Envelope &envelope) {
    return envelope.AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool WriteEnvelope::add_to_envelope(::zippylog::Envelope *envelope) {
    return envelope->AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool WriteEnvelope::add_to_envelope(::zippylog::Envelope &envelope) {
    return envelope.AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool WriteEnvelopeFromMessages::add_to_envelope(::zippylog::Envelope *envelope) {
    return envelope->AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool WriteEnvelopeFromMessages::add_to_envelope(::zippylog::Envelope &envelope) {
    return envelope.AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool SubscribeStoreChanges::add_to_envelope(::zippylog::Envelope *envelope) {
    return envelope->AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool SubscribeStoreChanges::add_to_envelope(::zippylog::Envelope &envelope) {
    return envelope.AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool SubscribeEnvelopes::add_to_envelope(::zippylog::Envelope *envelope) {
    return envelope->AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool SubscribeEnvelopes::add_to_envelope(::zippylog::Envelope &envelope) {
    return envelope.AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool SubscribeKeepalive::add_to_envelope(::zippylog::Envelope *envelope) {
    return envelope->AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool SubscribeKeepalive::add_to_envelope(::zippylog::Envelope &envelope) {
    return envelope.AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool SubscribeCancel::add_to_envelope(::zippylog::Envelope *envelope) {
    return envelope->AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}

bool SubscribeCancel::add_to_envelope(::zippylog::Envelope &envelope) {
    return envelope.AddMessage(*this, zippylog_namespace, zippylog_enumeration);
}
// @@protoc_insertion_point(namespace_scope)

}  // namespace request
}  // namespace protocol
}  // namespace zippylog

// @@protoc_insertion_point(global_scope)
