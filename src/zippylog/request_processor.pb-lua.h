// Generated by the lua-protobuf compiler.
// You shouldn't be editing this file manually
//
// source proto file: zippylog/request_processor.proto

#ifndef LUA_PROTOBUF_zippylog_request_processor_H
#define LUA_PROTOBUF_zippylog_request_processor_H

#include "lua-protobuf.h"
#include <zippylog/request_processor.pb.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <lua.h>

// register all messages in this package to a Lua state
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_open(lua_State *L);

// Message Create
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Create_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_Create_pushcopy(lua_State *L, const ::zippylog::request_processor::Create &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_Create_pushreference(lua_State *L, ::zippylog::request_processor::Create *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Create_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Create_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Create_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Create_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Create_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Create_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Create_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Create_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Create_has_id(lua_State *L);

// end of message Create

// Message Destroy
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Destroy_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_Destroy_pushcopy(lua_State *L, const ::zippylog::request_processor::Destroy &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_Destroy_pushreference(lua_State *L, ::zippylog::request_processor::Destroy *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Destroy_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Destroy_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Destroy_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Destroy_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Destroy_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Destroy_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Destroy_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Destroy_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_Destroy_has_id(lua_State *L);

// end of message Destroy

// Message RunStart
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStart_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_RunStart_pushcopy(lua_State *L, const ::zippylog::request_processor::RunStart &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_RunStart_pushreference(lua_State *L, ::zippylog::request_processor::RunStart *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStart_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStart_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStart_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStart_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStart_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStart_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStart_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStart_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStart_has_id(lua_State *L);

// end of message RunStart

// Message RunStop
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStop_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_RunStop_pushcopy(lua_State *L, const ::zippylog::request_processor::RunStop &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_RunStop_pushreference(lua_State *L, ::zippylog::request_processor::RunStop *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStop_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStop_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStop_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStop_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStop_clear(lua_State *L);

// optional bytes id = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStop_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStop_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStop_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_RunStop_has_id(lua_State *L);

// end of message RunStop

// Message FailReceiveMessage
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_FailReceiveMessage_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_FailReceiveMessage_pushcopy(lua_State *L, const ::zippylog::request_processor::FailReceiveMessage &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_FailReceiveMessage_pushreference(lua_State *L, ::zippylog::request_processor::FailReceiveMessage *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_FailReceiveMessage_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_FailReceiveMessage_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_FailReceiveMessage_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_FailReceiveMessage_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_FailReceiveMessage_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_FailReceiveMessage_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_FailReceiveMessage_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_FailReceiveMessage_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_FailReceiveMessage_has_id(lua_State *L);

// end of message FailReceiveMessage

// Message ReceiveEmptyMessage
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveEmptyMessage_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_ReceiveEmptyMessage_pushcopy(lua_State *L, const ::zippylog::request_processor::ReceiveEmptyMessage &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_ReceiveEmptyMessage_pushreference(lua_State *L, ::zippylog::request_processor::ReceiveEmptyMessage *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveEmptyMessage_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveEmptyMessage_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveEmptyMessage_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveEmptyMessage_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveEmptyMessage_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveEmptyMessage_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveEmptyMessage_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveEmptyMessage_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveEmptyMessage_has_id(lua_State *L);

// end of message ReceiveEmptyMessage

// Message UnknownMessageVersion
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_UnknownMessageVersion_pushcopy(lua_State *L, const ::zippylog::request_processor::UnknownMessageVersion &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_UnknownMessageVersion_pushreference(lua_State *L, ::zippylog::request_processor::UnknownMessageVersion *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_has_id(lua_State *L);

// optional uint32 version = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_clear_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_get_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_set_version(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownMessageVersion_has_version(lua_State *L);

// end of message UnknownMessageVersion

// Message UnknownRequestType
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_UnknownRequestType_pushcopy(lua_State *L, const ::zippylog::request_processor::UnknownRequestType &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_UnknownRequestType_pushreference(lua_State *L, ::zippylog::request_processor::UnknownRequestType *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_has_id(lua_State *L);

// optional uint32 enumeration = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_clear_enumeration(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_get_enumeration(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_set_enumeration(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_UnknownRequestType_has_enumeration(lua_State *L);

// end of message UnknownRequestType

// Message EnvelopeParseFailure
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_pushcopy(lua_State *L, const ::zippylog::request_processor::EnvelopeParseFailure &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_pushreference(lua_State *L, ::zippylog::request_processor::EnvelopeParseFailure *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_has_id(lua_State *L);

// optional bytes data = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_clear_data(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_get_data(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_set_data(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeParseFailure_has_data(lua_State *L);

// end of message EnvelopeParseFailure

// Message EmptyEnvelope
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EmptyEnvelope_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EmptyEnvelope_pushcopy(lua_State *L, const ::zippylog::request_processor::EmptyEnvelope &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EmptyEnvelope_pushreference(lua_State *L, ::zippylog::request_processor::EmptyEnvelope *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EmptyEnvelope_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EmptyEnvelope_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EmptyEnvelope_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EmptyEnvelope_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EmptyEnvelope_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EmptyEnvelope_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EmptyEnvelope_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EmptyEnvelope_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EmptyEnvelope_has_id(lua_State *L);

// end of message EmptyEnvelope

// Message InvalidMessageEnumeration
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_InvalidMessageEnumeration_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_InvalidMessageEnumeration_pushcopy(lua_State *L, const ::zippylog::request_processor::InvalidMessageEnumeration &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_InvalidMessageEnumeration_pushreference(lua_State *L, ::zippylog::request_processor::InvalidMessageEnumeration *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_InvalidMessageEnumeration_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_InvalidMessageEnumeration_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_InvalidMessageEnumeration_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_InvalidMessageEnumeration_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_InvalidMessageEnumeration_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_InvalidMessageEnumeration_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_InvalidMessageEnumeration_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_InvalidMessageEnumeration_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_InvalidMessageEnumeration_has_id(lua_State *L);

// end of message InvalidMessageEnumeration

// Message EnvelopeEmbeddedMessageParseFailure
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeEmbeddedMessageParseFailure_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EnvelopeEmbeddedMessageParseFailure_pushcopy(lua_State *L, const ::zippylog::request_processor::EnvelopeEmbeddedMessageParseFailure &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EnvelopeEmbeddedMessageParseFailure_pushreference(lua_State *L, ::zippylog::request_processor::EnvelopeEmbeddedMessageParseFailure *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeEmbeddedMessageParseFailure_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeEmbeddedMessageParseFailure_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeEmbeddedMessageParseFailure_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeEmbeddedMessageParseFailure_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeEmbeddedMessageParseFailure_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeEmbeddedMessageParseFailure_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeEmbeddedMessageParseFailure_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeEmbeddedMessageParseFailure_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EnvelopeEmbeddedMessageParseFailure_has_id(lua_State *L);

// end of message EnvelopeEmbeddedMessageParseFailure

// Message BeginProcessStoreInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStoreInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_BeginProcessStoreInfo_pushcopy(lua_State *L, const ::zippylog::request_processor::BeginProcessStoreInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_BeginProcessStoreInfo_pushreference(lua_State *L, ::zippylog::request_processor::BeginProcessStoreInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStoreInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStoreInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStoreInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStoreInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStoreInfo_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStoreInfo_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStoreInfo_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStoreInfo_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStoreInfo_has_id(lua_State *L);

// end of message BeginProcessStoreInfo

// Message EndProcessStoreInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStoreInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EndProcessStoreInfo_pushcopy(lua_State *L, const ::zippylog::request_processor::EndProcessStoreInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EndProcessStoreInfo_pushreference(lua_State *L, ::zippylog::request_processor::EndProcessStoreInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStoreInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStoreInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStoreInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStoreInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStoreInfo_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStoreInfo_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStoreInfo_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStoreInfo_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStoreInfo_has_id(lua_State *L);

// end of message EndProcessStoreInfo

// Message ReceiveInvalidGet
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveInvalidGet_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_ReceiveInvalidGet_pushcopy(lua_State *L, const ::zippylog::request_processor::ReceiveInvalidGet &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_ReceiveInvalidGet_pushreference(lua_State *L, ::zippylog::request_processor::ReceiveInvalidGet *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveInvalidGet_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveInvalidGet_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveInvalidGet_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveInvalidGet_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveInvalidGet_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveInvalidGet_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveInvalidGet_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveInvalidGet_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ReceiveInvalidGet_has_id(lua_State *L);

// end of message ReceiveInvalidGet

// Message GetInvalidStream
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidStream_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_GetInvalidStream_pushcopy(lua_State *L, const ::zippylog::request_processor::GetInvalidStream &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_GetInvalidStream_pushreference(lua_State *L, ::zippylog::request_processor::GetInvalidStream *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidStream_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidStream_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidStream_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidStream_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidStream_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidStream_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidStream_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidStream_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidStream_has_id(lua_State *L);

// end of message GetInvalidStream

// Message GetInvalidOffset
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidOffset_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_GetInvalidOffset_pushcopy(lua_State *L, const ::zippylog::request_processor::GetInvalidOffset &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_GetInvalidOffset_pushreference(lua_State *L, ::zippylog::request_processor::GetInvalidOffset *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidOffset_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidOffset_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidOffset_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidOffset_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidOffset_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidOffset_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidOffset_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidOffset_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_GetInvalidOffset_has_id(lua_State *L);

// end of message GetInvalidOffset

// Message BeginProcessGetStream
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessGetStream_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_BeginProcessGetStream_pushcopy(lua_State *L, const ::zippylog::request_processor::BeginProcessGetStream &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_BeginProcessGetStream_pushreference(lua_State *L, ::zippylog::request_processor::BeginProcessGetStream *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessGetStream_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessGetStream_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessGetStream_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessGetStream_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessGetStream_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessGetStream_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessGetStream_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessGetStream_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessGetStream_has_id(lua_State *L);

// end of message BeginProcessGetStream

// Message EndProcessGetStream
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessGetStream_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EndProcessGetStream_pushcopy(lua_State *L, const ::zippylog::request_processor::EndProcessGetStream &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EndProcessGetStream_pushreference(lua_State *L, ::zippylog::request_processor::EndProcessGetStream *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessGetStream_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessGetStream_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessGetStream_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessGetStream_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessGetStream_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessGetStream_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessGetStream_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessGetStream_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessGetStream_has_id(lua_State *L);

// end of message EndProcessGetStream

// Message SendErrorResponse
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_SendErrorResponse_pushcopy(lua_State *L, const ::zippylog::request_processor::SendErrorResponse &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_SendErrorResponse_pushreference(lua_State *L, ::zippylog::request_processor::SendErrorResponse *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_has_id(lua_State *L);

// optional string message = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_clear_message(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_get_message(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_set_message(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_SendErrorResponse_has_message(lua_State *L);

// end of message SendErrorResponse

// Message ForwardSubscribeKeepalive
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_pushcopy(lua_State *L, const ::zippylog::request_processor::ForwardSubscribeKeepalive &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_pushreference(lua_State *L, ::zippylog::request_processor::ForwardSubscribeKeepalive *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_has_id(lua_State *L);

// optional bytes subscription = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_clear_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_get_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_set_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_ForwardSubscribeKeepalive_has_subscription(lua_State *L);

// end of message ForwardSubscribeKeepalive

// Message BeginProcessBucketInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_pushcopy(lua_State *L, const ::zippylog::request_processor::BeginProcessBucketInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_pushreference(lua_State *L, ::zippylog::request_processor::BeginProcessBucketInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_has_id(lua_State *L);

// optional string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessBucketInfo_has_path(lua_State *L);

// end of message BeginProcessBucketInfo

// Message EndProcessBucketInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_pushcopy(lua_State *L, const ::zippylog::request_processor::EndProcessBucketInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_pushreference(lua_State *L, ::zippylog::request_processor::EndProcessBucketInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_has_id(lua_State *L);

// optional string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessBucketInfo_has_path(lua_State *L);

// end of message EndProcessBucketInfo

// Message BeginProcessStreamSetInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_pushcopy(lua_State *L, const ::zippylog::request_processor::BeginProcessStreamSetInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_pushreference(lua_State *L, ::zippylog::request_processor::BeginProcessStreamSetInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_has_id(lua_State *L);

// optional string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamSetInfo_has_path(lua_State *L);

// end of message BeginProcessStreamSetInfo

// Message EndProcessStreamSetInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_pushcopy(lua_State *L, const ::zippylog::request_processor::EndProcessStreamSetInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_pushreference(lua_State *L, ::zippylog::request_processor::EndProcessStreamSetInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_has_id(lua_State *L);

// optional string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamSetInfo_has_path(lua_State *L);

// end of message EndProcessStreamSetInfo

// Message BeginProcessStreamInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_pushcopy(lua_State *L, const ::zippylog::request_processor::BeginProcessStreamInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_pushreference(lua_State *L, ::zippylog::request_processor::BeginProcessStreamInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_has_id(lua_State *L);

// optional string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessStreamInfo_has_path(lua_State *L);

// end of message BeginProcessStreamInfo

// Message EndProcessStreamInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_pushcopy(lua_State *L, const ::zippylog::request_processor::EndProcessStreamInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_pushreference(lua_State *L, ::zippylog::request_processor::EndProcessStreamInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_has_id(lua_State *L);

// optional string path = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessStreamInfo_has_path(lua_State *L);

// end of message EndProcessStreamInfo

// Message BeginProcessWriteEnvelope
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessWriteEnvelope_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_BeginProcessWriteEnvelope_pushcopy(lua_State *L, const ::zippylog::request_processor::BeginProcessWriteEnvelope &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_BeginProcessWriteEnvelope_pushreference(lua_State *L, ::zippylog::request_processor::BeginProcessWriteEnvelope *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessWriteEnvelope_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessWriteEnvelope_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessWriteEnvelope_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessWriteEnvelope_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessWriteEnvelope_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessWriteEnvelope_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessWriteEnvelope_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessWriteEnvelope_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_BeginProcessWriteEnvelope_has_id(lua_State *L);

// end of message BeginProcessWriteEnvelope

// Message EndProcessWriteEnvelope
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessWriteEnvelope_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EndProcessWriteEnvelope_pushcopy(lua_State *L, const ::zippylog::request_processor::EndProcessWriteEnvelope &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_request_processor_EndProcessWriteEnvelope_pushreference(lua_State *L, ::zippylog::request_processor::EndProcessWriteEnvelope *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessWriteEnvelope_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessWriteEnvelope_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessWriteEnvelope_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessWriteEnvelope_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessWriteEnvelope_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessWriteEnvelope_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessWriteEnvelope_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessWriteEnvelope_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_request_processor_EndProcessWriteEnvelope_has_id(lua_State *L);

// end of message EndProcessWriteEnvelope

#ifdef __cplusplus
}
#endif

#endif