// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zippylog/protocol.proto

#ifndef PROTOBUF_zippylog_2fprotocol_2eproto__INCLUDED
#define PROTOBUF_zippylog_2fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <zippylog/envelope.hpp>
// @@protoc_insertion_point(includes)

namespace zippylog {
namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_zippylog_2fprotocol_2eproto();
void protobuf_AssignDesc_zippylog_2fprotocol_2eproto();
void protobuf_ShutdownFile_zippylog_2fprotocol_2eproto();

class StreamInfoV1;
class StreamSetInfoV1;
class BucketInfoV1;
class StoreInfoV1;
class StoreChangeStreamAddedV1;
class StoreChangeStreamDeletedV1;
class StoreChangeStreamAppendedV1;
class StoreChangeBucketAddedV1;
class StoreChangeBucketDeletedV1;
class StoreChangeStreamSetAddedV1;
class StoreChangeStreamSetDeletedV1;
class PluginStateV1;

enum PluginRunState {
  RUNNING = 1,
  ERROR = 2
};
bool PluginRunState_IsValid(int value);
const PluginRunState PluginRunState_MIN = RUNNING;
const PluginRunState PluginRunState_MAX = ERROR;
const int PluginRunState_ARRAYSIZE = PluginRunState_MAX + 1;

const ::google::protobuf::EnumDescriptor* PluginRunState_descriptor();
inline const ::std::string& PluginRunState_Name(PluginRunState value) {
  return ::google::protobuf::internal::NameOfEnum(
    PluginRunState_descriptor(), value);
}
inline bool PluginRunState_Parse(
    const ::std::string& name, PluginRunState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PluginRunState>(
    PluginRunState_descriptor(), name, value);
}
enum PluginErrorReason {
  LUA_MEMORY_CEILING = 1,
  LUA_INSTRUCTION_CEILING = 2,
  LUA_EXECUTION_ERROR = 3
};
bool PluginErrorReason_IsValid(int value);
const PluginErrorReason PluginErrorReason_MIN = LUA_MEMORY_CEILING;
const PluginErrorReason PluginErrorReason_MAX = LUA_EXECUTION_ERROR;
const int PluginErrorReason_ARRAYSIZE = PluginErrorReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* PluginErrorReason_descriptor();
inline const ::std::string& PluginErrorReason_Name(PluginErrorReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    PluginErrorReason_descriptor(), value);
}
inline bool PluginErrorReason_Parse(
    const ::std::string& name, PluginErrorReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PluginErrorReason>(
    PluginErrorReason_descriptor(), name, value);
}
// ===================================================================

class StreamInfoV1 : public ::google::protobuf::Message {
 public:
  StreamInfoV1();
  virtual ~StreamInfoV1();
  
  StreamInfoV1(const StreamInfoV1& from);
  
  inline StreamInfoV1& operator=(const StreamInfoV1& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamInfoV1& default_instance();
  
  void Swap(StreamInfoV1* other);
  
  // implements Message ----------------------------------------------
  
  StreamInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamInfoV1& from);
  void MergeFrom(const StreamInfoV1& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // optional uint64 length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline ::google::protobuf::uint64 length() const;
  inline void set_length(::google::protobuf::uint64 value);
  
  static const ::google::protobuf::uint32 zippylog_namespace = 1;
  static const ::google::protobuf::uint32 zippylog_enumeration = 93;
  
  bool add_to_envelope(::zippylog::Envelope *envelope);
  bool add_to_envelope(::zippylog::Envelope &envelope);
  // @@protoc_insertion_point(class_scope:zippylog.protocol.StreamInfoV1)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_length();
  inline void clear_has_length();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* path_;
  ::google::protobuf::uint64 length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_zippylog_2fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static StreamInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class StreamSetInfoV1 : public ::google::protobuf::Message {
 public:
  StreamSetInfoV1();
  virtual ~StreamSetInfoV1();
  
  StreamSetInfoV1(const StreamSetInfoV1& from);
  
  inline StreamSetInfoV1& operator=(const StreamSetInfoV1& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamSetInfoV1& default_instance();
  
  void Swap(StreamSetInfoV1* other);
  
  // implements Message ----------------------------------------------
  
  StreamSetInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamSetInfoV1& from);
  void MergeFrom(const StreamSetInfoV1& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // repeated .zippylog.protocol.StreamInfoV1 stream = 2;
  inline int stream_size() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 2;
  inline const ::zippylog::protocol::StreamInfoV1& stream(int index) const;
  inline ::zippylog::protocol::StreamInfoV1* mutable_stream(int index);
  inline ::zippylog::protocol::StreamInfoV1* add_stream();
  inline const ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::StreamInfoV1 >&
      stream() const;
  inline ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::StreamInfoV1 >*
      mutable_stream();
  
  static const ::google::protobuf::uint32 zippylog_namespace = 1;
  static const ::google::protobuf::uint32 zippylog_enumeration = 94;
  
  bool add_to_envelope(::zippylog::Envelope *envelope);
  bool add_to_envelope(::zippylog::Envelope &envelope);
  // @@protoc_insertion_point(class_scope:zippylog.protocol.StreamSetInfoV1)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* path_;
  ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::StreamInfoV1 > stream_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_zippylog_2fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static StreamSetInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class BucketInfoV1 : public ::google::protobuf::Message {
 public:
  BucketInfoV1();
  virtual ~BucketInfoV1();
  
  BucketInfoV1(const BucketInfoV1& from);
  
  inline BucketInfoV1& operator=(const BucketInfoV1& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BucketInfoV1& default_instance();
  
  void Swap(BucketInfoV1* other);
  
  // implements Message ----------------------------------------------
  
  BucketInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BucketInfoV1& from);
  void MergeFrom(const BucketInfoV1& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // repeated .zippylog.protocol.StreamSetInfoV1 stream_set = 2;
  inline int stream_set_size() const;
  inline void clear_stream_set();
  static const int kStreamSetFieldNumber = 2;
  inline const ::zippylog::protocol::StreamSetInfoV1& stream_set(int index) const;
  inline ::zippylog::protocol::StreamSetInfoV1* mutable_stream_set(int index);
  inline ::zippylog::protocol::StreamSetInfoV1* add_stream_set();
  inline const ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::StreamSetInfoV1 >&
      stream_set() const;
  inline ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::StreamSetInfoV1 >*
      mutable_stream_set();
  
  static const ::google::protobuf::uint32 zippylog_namespace = 1;
  static const ::google::protobuf::uint32 zippylog_enumeration = 95;
  
  bool add_to_envelope(::zippylog::Envelope *envelope);
  bool add_to_envelope(::zippylog::Envelope &envelope);
  // @@protoc_insertion_point(class_scope:zippylog.protocol.BucketInfoV1)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* path_;
  ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::StreamSetInfoV1 > stream_set_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_zippylog_2fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static BucketInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class StoreInfoV1 : public ::google::protobuf::Message {
 public:
  StoreInfoV1();
  virtual ~StoreInfoV1();
  
  StoreInfoV1(const StoreInfoV1& from);
  
  inline StoreInfoV1& operator=(const StoreInfoV1& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreInfoV1& default_instance();
  
  void Swap(StoreInfoV1* other);
  
  // implements Message ----------------------------------------------
  
  StoreInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreInfoV1& from);
  void MergeFrom(const StoreInfoV1& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .zippylog.protocol.BucketInfoV1 bucket = 1;
  inline int bucket_size() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::zippylog::protocol::BucketInfoV1& bucket(int index) const;
  inline ::zippylog::protocol::BucketInfoV1* mutable_bucket(int index);
  inline ::zippylog::protocol::BucketInfoV1* add_bucket();
  inline const ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::BucketInfoV1 >&
      bucket() const;
  inline ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::BucketInfoV1 >*
      mutable_bucket();
  
  static const ::google::protobuf::uint32 zippylog_namespace = 1;
  static const ::google::protobuf::uint32 zippylog_enumeration = 96;
  
  bool add_to_envelope(::zippylog::Envelope *envelope);
  bool add_to_envelope(::zippylog::Envelope &envelope);
  // @@protoc_insertion_point(class_scope:zippylog.protocol.StoreInfoV1)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::BucketInfoV1 > bucket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_zippylog_2fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static StoreInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class StoreChangeStreamAddedV1 : public ::google::protobuf::Message {
 public:
  StoreChangeStreamAddedV1();
  virtual ~StoreChangeStreamAddedV1();
  
  StoreChangeStreamAddedV1(const StoreChangeStreamAddedV1& from);
  
  inline StoreChangeStreamAddedV1& operator=(const StoreChangeStreamAddedV1& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreChangeStreamAddedV1& default_instance();
  
  void Swap(StoreChangeStreamAddedV1* other);
  
  // implements Message ----------------------------------------------
  
  StoreChangeStreamAddedV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreChangeStreamAddedV1& from);
  void MergeFrom(const StoreChangeStreamAddedV1& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const char* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // required string stream_set = 2;
  inline bool has_stream_set() const;
  inline void clear_stream_set();
  static const int kStreamSetFieldNumber = 2;
  inline const ::std::string& stream_set() const;
  inline void set_stream_set(const ::std::string& value);
  inline void set_stream_set(const char* value);
  inline void set_stream_set(const char* value, size_t size);
  inline ::std::string* mutable_stream_set();
  inline ::std::string* release_stream_set();
  
  // required string stream = 3;
  inline bool has_stream() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 3;
  inline const ::std::string& stream() const;
  inline void set_stream(const ::std::string& value);
  inline void set_stream(const char* value);
  inline void set_stream(const char* value, size_t size);
  inline ::std::string* mutable_stream();
  inline ::std::string* release_stream();
  
  // optional uint64 length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline ::google::protobuf::uint64 length() const;
  inline void set_length(::google::protobuf::uint64 value);
  
  static const ::google::protobuf::uint32 zippylog_namespace = 1;
  static const ::google::protobuf::uint32 zippylog_enumeration = 97;
  
  bool add_to_envelope(::zippylog::Envelope *envelope);
  bool add_to_envelope(::zippylog::Envelope &envelope);
  // @@protoc_insertion_point(class_scope:zippylog.protocol.StoreChangeStreamAddedV1)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_stream_set();
  inline void clear_has_stream_set();
  inline void set_has_stream();
  inline void clear_has_stream();
  inline void set_has_length();
  inline void clear_has_length();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* stream_set_;
  ::std::string* stream_;
  ::google::protobuf::uint64 length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_zippylog_2fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static StoreChangeStreamAddedV1* default_instance_;
};
// -------------------------------------------------------------------

class StoreChangeStreamDeletedV1 : public ::google::protobuf::Message {
 public:
  StoreChangeStreamDeletedV1();
  virtual ~StoreChangeStreamDeletedV1();
  
  StoreChangeStreamDeletedV1(const StoreChangeStreamDeletedV1& from);
  
  inline StoreChangeStreamDeletedV1& operator=(const StoreChangeStreamDeletedV1& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreChangeStreamDeletedV1& default_instance();
  
  void Swap(StoreChangeStreamDeletedV1* other);
  
  // implements Message ----------------------------------------------
  
  StoreChangeStreamDeletedV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreChangeStreamDeletedV1& from);
  void MergeFrom(const StoreChangeStreamDeletedV1& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const char* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // required string stream_set = 2;
  inline bool has_stream_set() const;
  inline void clear_stream_set();
  static const int kStreamSetFieldNumber = 2;
  inline const ::std::string& stream_set() const;
  inline void set_stream_set(const ::std::string& value);
  inline void set_stream_set(const char* value);
  inline void set_stream_set(const char* value, size_t size);
  inline ::std::string* mutable_stream_set();
  inline ::std::string* release_stream_set();
  
  // required string stream = 3;
  inline bool has_stream() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 3;
  inline const ::std::string& stream() const;
  inline void set_stream(const ::std::string& value);
  inline void set_stream(const char* value);
  inline void set_stream(const char* value, size_t size);
  inline ::std::string* mutable_stream();
  inline ::std::string* release_stream();
  
  // optional uint64 length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline ::google::protobuf::uint64 length() const;
  inline void set_length(::google::protobuf::uint64 value);
  
  static const ::google::protobuf::uint32 zippylog_namespace = 1;
  static const ::google::protobuf::uint32 zippylog_enumeration = 98;
  
  bool add_to_envelope(::zippylog::Envelope *envelope);
  bool add_to_envelope(::zippylog::Envelope &envelope);
  // @@protoc_insertion_point(class_scope:zippylog.protocol.StoreChangeStreamDeletedV1)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_stream_set();
  inline void clear_has_stream_set();
  inline void set_has_stream();
  inline void clear_has_stream();
  inline void set_has_length();
  inline void clear_has_length();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* stream_set_;
  ::std::string* stream_;
  ::google::protobuf::uint64 length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_zippylog_2fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static StoreChangeStreamDeletedV1* default_instance_;
};
// -------------------------------------------------------------------

class StoreChangeStreamAppendedV1 : public ::google::protobuf::Message {
 public:
  StoreChangeStreamAppendedV1();
  virtual ~StoreChangeStreamAppendedV1();
  
  StoreChangeStreamAppendedV1(const StoreChangeStreamAppendedV1& from);
  
  inline StoreChangeStreamAppendedV1& operator=(const StoreChangeStreamAppendedV1& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreChangeStreamAppendedV1& default_instance();
  
  void Swap(StoreChangeStreamAppendedV1* other);
  
  // implements Message ----------------------------------------------
  
  StoreChangeStreamAppendedV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreChangeStreamAppendedV1& from);
  void MergeFrom(const StoreChangeStreamAppendedV1& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const char* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // required string stream_set = 2;
  inline bool has_stream_set() const;
  inline void clear_stream_set();
  static const int kStreamSetFieldNumber = 2;
  inline const ::std::string& stream_set() const;
  inline void set_stream_set(const ::std::string& value);
  inline void set_stream_set(const char* value);
  inline void set_stream_set(const char* value, size_t size);
  inline ::std::string* mutable_stream_set();
  inline ::std::string* release_stream_set();
  
  // required string stream = 3;
  inline bool has_stream() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 3;
  inline const ::std::string& stream() const;
  inline void set_stream(const ::std::string& value);
  inline void set_stream(const char* value);
  inline void set_stream(const char* value, size_t size);
  inline ::std::string* mutable_stream();
  inline ::std::string* release_stream();
  
  // optional uint64 length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline ::google::protobuf::uint64 length() const;
  inline void set_length(::google::protobuf::uint64 value);
  
  static const ::google::protobuf::uint32 zippylog_namespace = 1;
  static const ::google::protobuf::uint32 zippylog_enumeration = 99;
  
  bool add_to_envelope(::zippylog::Envelope *envelope);
  bool add_to_envelope(::zippylog::Envelope &envelope);
  // @@protoc_insertion_point(class_scope:zippylog.protocol.StoreChangeStreamAppendedV1)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_stream_set();
  inline void clear_has_stream_set();
  inline void set_has_stream();
  inline void clear_has_stream();
  inline void set_has_length();
  inline void clear_has_length();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* stream_set_;
  ::std::string* stream_;
  ::google::protobuf::uint64 length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_zippylog_2fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static StoreChangeStreamAppendedV1* default_instance_;
};
// -------------------------------------------------------------------

class StoreChangeBucketAddedV1 : public ::google::protobuf::Message {
 public:
  StoreChangeBucketAddedV1();
  virtual ~StoreChangeBucketAddedV1();
  
  StoreChangeBucketAddedV1(const StoreChangeBucketAddedV1& from);
  
  inline StoreChangeBucketAddedV1& operator=(const StoreChangeBucketAddedV1& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreChangeBucketAddedV1& default_instance();
  
  void Swap(StoreChangeBucketAddedV1* other);
  
  // implements Message ----------------------------------------------
  
  StoreChangeBucketAddedV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreChangeBucketAddedV1& from);
  void MergeFrom(const StoreChangeBucketAddedV1& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const char* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  static const ::google::protobuf::uint32 zippylog_namespace = 1;
  static const ::google::protobuf::uint32 zippylog_enumeration = 100;
  
  bool add_to_envelope(::zippylog::Envelope *envelope);
  bool add_to_envelope(::zippylog::Envelope &envelope);
  // @@protoc_insertion_point(class_scope:zippylog.protocol.StoreChangeBucketAddedV1)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_zippylog_2fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static StoreChangeBucketAddedV1* default_instance_;
};
// -------------------------------------------------------------------

class StoreChangeBucketDeletedV1 : public ::google::protobuf::Message {
 public:
  StoreChangeBucketDeletedV1();
  virtual ~StoreChangeBucketDeletedV1();
  
  StoreChangeBucketDeletedV1(const StoreChangeBucketDeletedV1& from);
  
  inline StoreChangeBucketDeletedV1& operator=(const StoreChangeBucketDeletedV1& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreChangeBucketDeletedV1& default_instance();
  
  void Swap(StoreChangeBucketDeletedV1* other);
  
  // implements Message ----------------------------------------------
  
  StoreChangeBucketDeletedV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreChangeBucketDeletedV1& from);
  void MergeFrom(const StoreChangeBucketDeletedV1& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string bucket = 2;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 2;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const char* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  static const ::google::protobuf::uint32 zippylog_namespace = 1;
  static const ::google::protobuf::uint32 zippylog_enumeration = 101;
  
  bool add_to_envelope(::zippylog::Envelope *envelope);
  bool add_to_envelope(::zippylog::Envelope &envelope);
  // @@protoc_insertion_point(class_scope:zippylog.protocol.StoreChangeBucketDeletedV1)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_zippylog_2fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static StoreChangeBucketDeletedV1* default_instance_;
};
// -------------------------------------------------------------------

class StoreChangeStreamSetAddedV1 : public ::google::protobuf::Message {
 public:
  StoreChangeStreamSetAddedV1();
  virtual ~StoreChangeStreamSetAddedV1();
  
  StoreChangeStreamSetAddedV1(const StoreChangeStreamSetAddedV1& from);
  
  inline StoreChangeStreamSetAddedV1& operator=(const StoreChangeStreamSetAddedV1& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreChangeStreamSetAddedV1& default_instance();
  
  void Swap(StoreChangeStreamSetAddedV1* other);
  
  // implements Message ----------------------------------------------
  
  StoreChangeStreamSetAddedV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreChangeStreamSetAddedV1& from);
  void MergeFrom(const StoreChangeStreamSetAddedV1& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const char* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // required string stream_set = 2;
  inline bool has_stream_set() const;
  inline void clear_stream_set();
  static const int kStreamSetFieldNumber = 2;
  inline const ::std::string& stream_set() const;
  inline void set_stream_set(const ::std::string& value);
  inline void set_stream_set(const char* value);
  inline void set_stream_set(const char* value, size_t size);
  inline ::std::string* mutable_stream_set();
  inline ::std::string* release_stream_set();
  
  static const ::google::protobuf::uint32 zippylog_namespace = 1;
  static const ::google::protobuf::uint32 zippylog_enumeration = 102;
  
  bool add_to_envelope(::zippylog::Envelope *envelope);
  bool add_to_envelope(::zippylog::Envelope &envelope);
  // @@protoc_insertion_point(class_scope:zippylog.protocol.StoreChangeStreamSetAddedV1)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_stream_set();
  inline void clear_has_stream_set();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* stream_set_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_zippylog_2fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static StoreChangeStreamSetAddedV1* default_instance_;
};
// -------------------------------------------------------------------

class StoreChangeStreamSetDeletedV1 : public ::google::protobuf::Message {
 public:
  StoreChangeStreamSetDeletedV1();
  virtual ~StoreChangeStreamSetDeletedV1();
  
  StoreChangeStreamSetDeletedV1(const StoreChangeStreamSetDeletedV1& from);
  
  inline StoreChangeStreamSetDeletedV1& operator=(const StoreChangeStreamSetDeletedV1& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreChangeStreamSetDeletedV1& default_instance();
  
  void Swap(StoreChangeStreamSetDeletedV1* other);
  
  // implements Message ----------------------------------------------
  
  StoreChangeStreamSetDeletedV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreChangeStreamSetDeletedV1& from);
  void MergeFrom(const StoreChangeStreamSetDeletedV1& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const char* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // required string stream_set = 2;
  inline bool has_stream_set() const;
  inline void clear_stream_set();
  static const int kStreamSetFieldNumber = 2;
  inline const ::std::string& stream_set() const;
  inline void set_stream_set(const ::std::string& value);
  inline void set_stream_set(const char* value);
  inline void set_stream_set(const char* value, size_t size);
  inline ::std::string* mutable_stream_set();
  inline ::std::string* release_stream_set();
  
  static const ::google::protobuf::uint32 zippylog_namespace = 1;
  static const ::google::protobuf::uint32 zippylog_enumeration = 103;
  
  bool add_to_envelope(::zippylog::Envelope *envelope);
  bool add_to_envelope(::zippylog::Envelope &envelope);
  // @@protoc_insertion_point(class_scope:zippylog.protocol.StoreChangeStreamSetDeletedV1)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_stream_set();
  inline void clear_has_stream_set();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* stream_set_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_zippylog_2fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static StoreChangeStreamSetDeletedV1* default_instance_;
};
// -------------------------------------------------------------------

class PluginStateV1 : public ::google::protobuf::Message {
 public:
  PluginStateV1();
  virtual ~PluginStateV1();
  
  PluginStateV1(const PluginStateV1& from);
  
  inline PluginStateV1& operator=(const PluginStateV1& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PluginStateV1& default_instance();
  
  void Swap(PluginStateV1* other);
  
  // implements Message ----------------------------------------------
  
  PluginStateV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PluginStateV1& from);
  void MergeFrom(const PluginStateV1& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required .zippylog.protocol.PluginRunState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline zippylog::protocol::PluginRunState state() const;
  inline void set_state(zippylog::protocol::PluginRunState value);
  
  // optional .zippylog.protocol.PluginErrorReason error_code = 3;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 3;
  inline zippylog::protocol::PluginErrorReason error_code() const;
  inline void set_error_code(zippylog::protocol::PluginErrorReason value);
  
  // optional string error_message = 4;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 4;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  
  // required uint32 lua_current_memory = 5;
  inline bool has_lua_current_memory() const;
  inline void clear_lua_current_memory();
  static const int kLuaCurrentMemoryFieldNumber = 5;
  inline ::google::protobuf::uint32 lua_current_memory() const;
  inline void set_lua_current_memory(::google::protobuf::uint32 value);
  
  // required uint32 lua_max_memory = 6;
  inline bool has_lua_max_memory() const;
  inline void clear_lua_max_memory();
  static const int kLuaMaxMemoryFieldNumber = 6;
  inline ::google::protobuf::uint32 lua_max_memory() const;
  inline void set_lua_max_memory(::google::protobuf::uint32 value);
  
  static const ::google::protobuf::uint32 zippylog_namespace = 1;
  static const ::google::protobuf::uint32 zippylog_enumeration = 113;
  
  bool add_to_envelope(::zippylog::Envelope *envelope);
  bool add_to_envelope(::zippylog::Envelope &envelope);
  // @@protoc_insertion_point(class_scope:zippylog.protocol.PluginStateV1)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_error_message();
  inline void clear_has_error_message();
  inline void set_has_lua_current_memory();
  inline void clear_has_lua_current_memory();
  inline void set_has_lua_max_memory();
  inline void clear_has_lua_max_memory();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  int state_;
  int error_code_;
  ::std::string* error_message_;
  ::google::protobuf::uint32 lua_current_memory_;
  ::google::protobuf::uint32 lua_max_memory_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_zippylog_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_zippylog_2fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static PluginStateV1* default_instance_;
};
// ===================================================================


// ===================================================================

// StreamInfoV1

// required string path = 1;
inline bool StreamInfoV1::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamInfoV1::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamInfoV1::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamInfoV1::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& StreamInfoV1::path() const {
  return *path_;
}
inline void StreamInfoV1::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void StreamInfoV1::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void StreamInfoV1::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreamInfoV1::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* StreamInfoV1::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 length = 2;
inline bool StreamInfoV1::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreamInfoV1::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreamInfoV1::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreamInfoV1::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::uint64 StreamInfoV1::length() const {
  return length_;
}
inline void StreamInfoV1::set_length(::google::protobuf::uint64 value) {
  set_has_length();
  length_ = value;
}

// -------------------------------------------------------------------

// StreamSetInfoV1

// required string path = 1;
inline bool StreamSetInfoV1::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamSetInfoV1::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamSetInfoV1::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamSetInfoV1::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& StreamSetInfoV1::path() const {
  return *path_;
}
inline void StreamSetInfoV1::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void StreamSetInfoV1::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void StreamSetInfoV1::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreamSetInfoV1::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* StreamSetInfoV1::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .zippylog.protocol.StreamInfoV1 stream = 2;
inline int StreamSetInfoV1::stream_size() const {
  return stream_.size();
}
inline void StreamSetInfoV1::clear_stream() {
  stream_.Clear();
}
inline const ::zippylog::protocol::StreamInfoV1& StreamSetInfoV1::stream(int index) const {
  return stream_.Get(index);
}
inline ::zippylog::protocol::StreamInfoV1* StreamSetInfoV1::mutable_stream(int index) {
  return stream_.Mutable(index);
}
inline ::zippylog::protocol::StreamInfoV1* StreamSetInfoV1::add_stream() {
  return stream_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::StreamInfoV1 >&
StreamSetInfoV1::stream() const {
  return stream_;
}
inline ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::StreamInfoV1 >*
StreamSetInfoV1::mutable_stream() {
  return &stream_;
}

// -------------------------------------------------------------------

// BucketInfoV1

// required string path = 1;
inline bool BucketInfoV1::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BucketInfoV1::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BucketInfoV1::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BucketInfoV1::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& BucketInfoV1::path() const {
  return *path_;
}
inline void BucketInfoV1::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void BucketInfoV1::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void BucketInfoV1::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BucketInfoV1::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* BucketInfoV1::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .zippylog.protocol.StreamSetInfoV1 stream_set = 2;
inline int BucketInfoV1::stream_set_size() const {
  return stream_set_.size();
}
inline void BucketInfoV1::clear_stream_set() {
  stream_set_.Clear();
}
inline const ::zippylog::protocol::StreamSetInfoV1& BucketInfoV1::stream_set(int index) const {
  return stream_set_.Get(index);
}
inline ::zippylog::protocol::StreamSetInfoV1* BucketInfoV1::mutable_stream_set(int index) {
  return stream_set_.Mutable(index);
}
inline ::zippylog::protocol::StreamSetInfoV1* BucketInfoV1::add_stream_set() {
  return stream_set_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::StreamSetInfoV1 >&
BucketInfoV1::stream_set() const {
  return stream_set_;
}
inline ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::StreamSetInfoV1 >*
BucketInfoV1::mutable_stream_set() {
  return &stream_set_;
}

// -------------------------------------------------------------------

// StoreInfoV1

// repeated .zippylog.protocol.BucketInfoV1 bucket = 1;
inline int StoreInfoV1::bucket_size() const {
  return bucket_.size();
}
inline void StoreInfoV1::clear_bucket() {
  bucket_.Clear();
}
inline const ::zippylog::protocol::BucketInfoV1& StoreInfoV1::bucket(int index) const {
  return bucket_.Get(index);
}
inline ::zippylog::protocol::BucketInfoV1* StoreInfoV1::mutable_bucket(int index) {
  return bucket_.Mutable(index);
}
inline ::zippylog::protocol::BucketInfoV1* StoreInfoV1::add_bucket() {
  return bucket_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::BucketInfoV1 >&
StoreInfoV1::bucket() const {
  return bucket_;
}
inline ::google::protobuf::RepeatedPtrField< ::zippylog::protocol::BucketInfoV1 >*
StoreInfoV1::mutable_bucket() {
  return &bucket_;
}

// -------------------------------------------------------------------

// StoreChangeStreamAddedV1

// required string bucket = 1;
inline bool StoreChangeStreamAddedV1::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreChangeStreamAddedV1::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreChangeStreamAddedV1::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreChangeStreamAddedV1::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& StoreChangeStreamAddedV1::bucket() const {
  return *bucket_;
}
inline void StoreChangeStreamAddedV1::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeStreamAddedV1::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeStreamAddedV1::set_bucket(const char* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeStreamAddedV1::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* StoreChangeStreamAddedV1::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string stream_set = 2;
inline bool StoreChangeStreamAddedV1::has_stream_set() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreChangeStreamAddedV1::set_has_stream_set() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreChangeStreamAddedV1::clear_has_stream_set() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreChangeStreamAddedV1::clear_stream_set() {
  if (stream_set_ != &::google::protobuf::internal::kEmptyString) {
    stream_set_->clear();
  }
  clear_has_stream_set();
}
inline const ::std::string& StoreChangeStreamAddedV1::stream_set() const {
  return *stream_set_;
}
inline void StoreChangeStreamAddedV1::set_stream_set(const ::std::string& value) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(value);
}
inline void StoreChangeStreamAddedV1::set_stream_set(const char* value) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(value);
}
inline void StoreChangeStreamAddedV1::set_stream_set(const char* value, size_t size) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeStreamAddedV1::mutable_stream_set() {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  return stream_set_;
}
inline ::std::string* StoreChangeStreamAddedV1::release_stream_set() {
  clear_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stream_set_;
    stream_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string stream = 3;
inline bool StoreChangeStreamAddedV1::has_stream() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoreChangeStreamAddedV1::set_has_stream() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoreChangeStreamAddedV1::clear_has_stream() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoreChangeStreamAddedV1::clear_stream() {
  if (stream_ != &::google::protobuf::internal::kEmptyString) {
    stream_->clear();
  }
  clear_has_stream();
}
inline const ::std::string& StoreChangeStreamAddedV1::stream() const {
  return *stream_;
}
inline void StoreChangeStreamAddedV1::set_stream(const ::std::string& value) {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  stream_->assign(value);
}
inline void StoreChangeStreamAddedV1::set_stream(const char* value) {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  stream_->assign(value);
}
inline void StoreChangeStreamAddedV1::set_stream(const char* value, size_t size) {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  stream_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeStreamAddedV1::mutable_stream() {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  return stream_;
}
inline ::std::string* StoreChangeStreamAddedV1::release_stream() {
  clear_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stream_;
    stream_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 length = 4;
inline bool StoreChangeStreamAddedV1::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StoreChangeStreamAddedV1::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StoreChangeStreamAddedV1::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StoreChangeStreamAddedV1::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::uint64 StoreChangeStreamAddedV1::length() const {
  return length_;
}
inline void StoreChangeStreamAddedV1::set_length(::google::protobuf::uint64 value) {
  set_has_length();
  length_ = value;
}

// -------------------------------------------------------------------

// StoreChangeStreamDeletedV1

// required string bucket = 1;
inline bool StoreChangeStreamDeletedV1::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreChangeStreamDeletedV1::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreChangeStreamDeletedV1::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreChangeStreamDeletedV1::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& StoreChangeStreamDeletedV1::bucket() const {
  return *bucket_;
}
inline void StoreChangeStreamDeletedV1::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeStreamDeletedV1::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeStreamDeletedV1::set_bucket(const char* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeStreamDeletedV1::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* StoreChangeStreamDeletedV1::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string stream_set = 2;
inline bool StoreChangeStreamDeletedV1::has_stream_set() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreChangeStreamDeletedV1::set_has_stream_set() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreChangeStreamDeletedV1::clear_has_stream_set() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreChangeStreamDeletedV1::clear_stream_set() {
  if (stream_set_ != &::google::protobuf::internal::kEmptyString) {
    stream_set_->clear();
  }
  clear_has_stream_set();
}
inline const ::std::string& StoreChangeStreamDeletedV1::stream_set() const {
  return *stream_set_;
}
inline void StoreChangeStreamDeletedV1::set_stream_set(const ::std::string& value) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(value);
}
inline void StoreChangeStreamDeletedV1::set_stream_set(const char* value) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(value);
}
inline void StoreChangeStreamDeletedV1::set_stream_set(const char* value, size_t size) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeStreamDeletedV1::mutable_stream_set() {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  return stream_set_;
}
inline ::std::string* StoreChangeStreamDeletedV1::release_stream_set() {
  clear_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stream_set_;
    stream_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string stream = 3;
inline bool StoreChangeStreamDeletedV1::has_stream() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoreChangeStreamDeletedV1::set_has_stream() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoreChangeStreamDeletedV1::clear_has_stream() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoreChangeStreamDeletedV1::clear_stream() {
  if (stream_ != &::google::protobuf::internal::kEmptyString) {
    stream_->clear();
  }
  clear_has_stream();
}
inline const ::std::string& StoreChangeStreamDeletedV1::stream() const {
  return *stream_;
}
inline void StoreChangeStreamDeletedV1::set_stream(const ::std::string& value) {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  stream_->assign(value);
}
inline void StoreChangeStreamDeletedV1::set_stream(const char* value) {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  stream_->assign(value);
}
inline void StoreChangeStreamDeletedV1::set_stream(const char* value, size_t size) {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  stream_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeStreamDeletedV1::mutable_stream() {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  return stream_;
}
inline ::std::string* StoreChangeStreamDeletedV1::release_stream() {
  clear_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stream_;
    stream_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 length = 4;
inline bool StoreChangeStreamDeletedV1::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StoreChangeStreamDeletedV1::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StoreChangeStreamDeletedV1::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StoreChangeStreamDeletedV1::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::uint64 StoreChangeStreamDeletedV1::length() const {
  return length_;
}
inline void StoreChangeStreamDeletedV1::set_length(::google::protobuf::uint64 value) {
  set_has_length();
  length_ = value;
}

// -------------------------------------------------------------------

// StoreChangeStreamAppendedV1

// required string bucket = 1;
inline bool StoreChangeStreamAppendedV1::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreChangeStreamAppendedV1::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreChangeStreamAppendedV1::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreChangeStreamAppendedV1::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& StoreChangeStreamAppendedV1::bucket() const {
  return *bucket_;
}
inline void StoreChangeStreamAppendedV1::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeStreamAppendedV1::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeStreamAppendedV1::set_bucket(const char* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeStreamAppendedV1::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* StoreChangeStreamAppendedV1::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string stream_set = 2;
inline bool StoreChangeStreamAppendedV1::has_stream_set() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreChangeStreamAppendedV1::set_has_stream_set() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreChangeStreamAppendedV1::clear_has_stream_set() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreChangeStreamAppendedV1::clear_stream_set() {
  if (stream_set_ != &::google::protobuf::internal::kEmptyString) {
    stream_set_->clear();
  }
  clear_has_stream_set();
}
inline const ::std::string& StoreChangeStreamAppendedV1::stream_set() const {
  return *stream_set_;
}
inline void StoreChangeStreamAppendedV1::set_stream_set(const ::std::string& value) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(value);
}
inline void StoreChangeStreamAppendedV1::set_stream_set(const char* value) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(value);
}
inline void StoreChangeStreamAppendedV1::set_stream_set(const char* value, size_t size) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeStreamAppendedV1::mutable_stream_set() {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  return stream_set_;
}
inline ::std::string* StoreChangeStreamAppendedV1::release_stream_set() {
  clear_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stream_set_;
    stream_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string stream = 3;
inline bool StoreChangeStreamAppendedV1::has_stream() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoreChangeStreamAppendedV1::set_has_stream() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoreChangeStreamAppendedV1::clear_has_stream() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoreChangeStreamAppendedV1::clear_stream() {
  if (stream_ != &::google::protobuf::internal::kEmptyString) {
    stream_->clear();
  }
  clear_has_stream();
}
inline const ::std::string& StoreChangeStreamAppendedV1::stream() const {
  return *stream_;
}
inline void StoreChangeStreamAppendedV1::set_stream(const ::std::string& value) {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  stream_->assign(value);
}
inline void StoreChangeStreamAppendedV1::set_stream(const char* value) {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  stream_->assign(value);
}
inline void StoreChangeStreamAppendedV1::set_stream(const char* value, size_t size) {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  stream_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeStreamAppendedV1::mutable_stream() {
  set_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    stream_ = new ::std::string;
  }
  return stream_;
}
inline ::std::string* StoreChangeStreamAppendedV1::release_stream() {
  clear_has_stream();
  if (stream_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stream_;
    stream_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 length = 4;
inline bool StoreChangeStreamAppendedV1::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StoreChangeStreamAppendedV1::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StoreChangeStreamAppendedV1::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StoreChangeStreamAppendedV1::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::uint64 StoreChangeStreamAppendedV1::length() const {
  return length_;
}
inline void StoreChangeStreamAppendedV1::set_length(::google::protobuf::uint64 value) {
  set_has_length();
  length_ = value;
}

// -------------------------------------------------------------------

// StoreChangeBucketAddedV1

// required string bucket = 1;
inline bool StoreChangeBucketAddedV1::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreChangeBucketAddedV1::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreChangeBucketAddedV1::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreChangeBucketAddedV1::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& StoreChangeBucketAddedV1::bucket() const {
  return *bucket_;
}
inline void StoreChangeBucketAddedV1::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeBucketAddedV1::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeBucketAddedV1::set_bucket(const char* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeBucketAddedV1::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* StoreChangeBucketAddedV1::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StoreChangeBucketDeletedV1

// required string bucket = 2;
inline bool StoreChangeBucketDeletedV1::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreChangeBucketDeletedV1::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreChangeBucketDeletedV1::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreChangeBucketDeletedV1::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& StoreChangeBucketDeletedV1::bucket() const {
  return *bucket_;
}
inline void StoreChangeBucketDeletedV1::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeBucketDeletedV1::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeBucketDeletedV1::set_bucket(const char* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeBucketDeletedV1::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* StoreChangeBucketDeletedV1::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StoreChangeStreamSetAddedV1

// required string bucket = 1;
inline bool StoreChangeStreamSetAddedV1::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreChangeStreamSetAddedV1::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreChangeStreamSetAddedV1::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreChangeStreamSetAddedV1::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& StoreChangeStreamSetAddedV1::bucket() const {
  return *bucket_;
}
inline void StoreChangeStreamSetAddedV1::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeStreamSetAddedV1::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeStreamSetAddedV1::set_bucket(const char* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeStreamSetAddedV1::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* StoreChangeStreamSetAddedV1::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string stream_set = 2;
inline bool StoreChangeStreamSetAddedV1::has_stream_set() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreChangeStreamSetAddedV1::set_has_stream_set() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreChangeStreamSetAddedV1::clear_has_stream_set() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreChangeStreamSetAddedV1::clear_stream_set() {
  if (stream_set_ != &::google::protobuf::internal::kEmptyString) {
    stream_set_->clear();
  }
  clear_has_stream_set();
}
inline const ::std::string& StoreChangeStreamSetAddedV1::stream_set() const {
  return *stream_set_;
}
inline void StoreChangeStreamSetAddedV1::set_stream_set(const ::std::string& value) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(value);
}
inline void StoreChangeStreamSetAddedV1::set_stream_set(const char* value) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(value);
}
inline void StoreChangeStreamSetAddedV1::set_stream_set(const char* value, size_t size) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeStreamSetAddedV1::mutable_stream_set() {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  return stream_set_;
}
inline ::std::string* StoreChangeStreamSetAddedV1::release_stream_set() {
  clear_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stream_set_;
    stream_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StoreChangeStreamSetDeletedV1

// required string bucket = 1;
inline bool StoreChangeStreamSetDeletedV1::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreChangeStreamSetDeletedV1::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreChangeStreamSetDeletedV1::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreChangeStreamSetDeletedV1::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& StoreChangeStreamSetDeletedV1::bucket() const {
  return *bucket_;
}
inline void StoreChangeStreamSetDeletedV1::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeStreamSetDeletedV1::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void StoreChangeStreamSetDeletedV1::set_bucket(const char* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeStreamSetDeletedV1::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* StoreChangeStreamSetDeletedV1::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string stream_set = 2;
inline bool StoreChangeStreamSetDeletedV1::has_stream_set() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreChangeStreamSetDeletedV1::set_has_stream_set() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreChangeStreamSetDeletedV1::clear_has_stream_set() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreChangeStreamSetDeletedV1::clear_stream_set() {
  if (stream_set_ != &::google::protobuf::internal::kEmptyString) {
    stream_set_->clear();
  }
  clear_has_stream_set();
}
inline const ::std::string& StoreChangeStreamSetDeletedV1::stream_set() const {
  return *stream_set_;
}
inline void StoreChangeStreamSetDeletedV1::set_stream_set(const ::std::string& value) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(value);
}
inline void StoreChangeStreamSetDeletedV1::set_stream_set(const char* value) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(value);
}
inline void StoreChangeStreamSetDeletedV1::set_stream_set(const char* value, size_t size) {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  stream_set_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChangeStreamSetDeletedV1::mutable_stream_set() {
  set_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    stream_set_ = new ::std::string;
  }
  return stream_set_;
}
inline ::std::string* StoreChangeStreamSetDeletedV1::release_stream_set() {
  clear_has_stream_set();
  if (stream_set_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stream_set_;
    stream_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PluginStateV1

// required string name = 1;
inline bool PluginStateV1::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PluginStateV1::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PluginStateV1::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PluginStateV1::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PluginStateV1::name() const {
  return *name_;
}
inline void PluginStateV1::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PluginStateV1::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PluginStateV1::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PluginStateV1::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PluginStateV1::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .zippylog.protocol.PluginRunState state = 2;
inline bool PluginStateV1::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PluginStateV1::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PluginStateV1::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PluginStateV1::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline zippylog::protocol::PluginRunState PluginStateV1::state() const {
  return static_cast< zippylog::protocol::PluginRunState >(state_);
}
inline void PluginStateV1::set_state(zippylog::protocol::PluginRunState value) {
  GOOGLE_DCHECK(zippylog::protocol::PluginRunState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional .zippylog.protocol.PluginErrorReason error_code = 3;
inline bool PluginStateV1::has_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PluginStateV1::set_has_error_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PluginStateV1::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PluginStateV1::clear_error_code() {
  error_code_ = 1;
  clear_has_error_code();
}
inline zippylog::protocol::PluginErrorReason PluginStateV1::error_code() const {
  return static_cast< zippylog::protocol::PluginErrorReason >(error_code_);
}
inline void PluginStateV1::set_error_code(zippylog::protocol::PluginErrorReason value) {
  GOOGLE_DCHECK(zippylog::protocol::PluginErrorReason_IsValid(value));
  set_has_error_code();
  error_code_ = value;
}

// optional string error_message = 4;
inline bool PluginStateV1::has_error_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PluginStateV1::set_has_error_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PluginStateV1::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PluginStateV1::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& PluginStateV1::error_message() const {
  return *error_message_;
}
inline void PluginStateV1::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void PluginStateV1::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void PluginStateV1::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PluginStateV1::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}
inline ::std::string* PluginStateV1::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 lua_current_memory = 5;
inline bool PluginStateV1::has_lua_current_memory() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PluginStateV1::set_has_lua_current_memory() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PluginStateV1::clear_has_lua_current_memory() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PluginStateV1::clear_lua_current_memory() {
  lua_current_memory_ = 0u;
  clear_has_lua_current_memory();
}
inline ::google::protobuf::uint32 PluginStateV1::lua_current_memory() const {
  return lua_current_memory_;
}
inline void PluginStateV1::set_lua_current_memory(::google::protobuf::uint32 value) {
  set_has_lua_current_memory();
  lua_current_memory_ = value;
}

// required uint32 lua_max_memory = 6;
inline bool PluginStateV1::has_lua_max_memory() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PluginStateV1::set_has_lua_max_memory() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PluginStateV1::clear_has_lua_max_memory() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PluginStateV1::clear_lua_max_memory() {
  lua_max_memory_ = 0u;
  clear_has_lua_max_memory();
}
inline ::google::protobuf::uint32 PluginStateV1::lua_max_memory() const {
  return lua_max_memory_;
}
inline void PluginStateV1::set_lua_max_memory(::google::protobuf::uint32 value) {
  set_has_lua_max_memory();
  lua_max_memory_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace zippylog

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< zippylog::protocol::PluginRunState>() {
  return zippylog::protocol::PluginRunState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< zippylog::protocol::PluginErrorReason>() {
  return zippylog::protocol::PluginErrorReason_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_zippylog_2fprotocol_2eproto__INCLUDED
