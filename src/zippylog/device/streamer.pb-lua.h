// Generated by the lua-protobuf compiler.
// You shouldn't be editing this file manually
//
// source proto file: zippylog/device/streamer.proto

#ifndef LUA_PROTOBUF_zippylog_device_streamer_H
#define LUA_PROTOBUF_zippylog_device_streamer_H

#include "lua-protobuf.h"
#include <zippylog/device/streamer.pb.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <lua.h>

// register all messages in this package to a Lua state
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_open(lua_State *L);

// Message Create
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Create_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_Create_pushcopy(lua_State *L, const ::zippylog::device::streamer::Create &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_Create_pushreference(lua_State *L, ::zippylog::device::streamer::Create *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Create_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Create_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Create_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Create_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Create_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Create_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Create_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Create_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Create_has_id(lua_State *L);

// end of message Create

// Message Destroy
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Destroy_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_Destroy_pushcopy(lua_State *L, const ::zippylog::device::streamer::Destroy &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_Destroy_pushreference(lua_State *L, ::zippylog::device::streamer::Destroy *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Destroy_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Destroy_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Destroy_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Destroy_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Destroy_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Destroy_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Destroy_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Destroy_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_Destroy_has_id(lua_State *L);

// end of message Destroy

// Message SubscriptionExpired
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_SubscriptionExpired_pushcopy(lua_State *L, const ::zippylog::device::streamer::SubscriptionExpired &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_SubscriptionExpired_pushreference(lua_State *L, ::zippylog::device::streamer::SubscriptionExpired *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_has_id(lua_State *L);

// optional bytes subscription = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_clear_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_get_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_set_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionExpired_has_subscription(lua_State *L);

// end of message SubscriptionExpired

// Message ReceiveKeepalive
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_pushcopy(lua_State *L, const ::zippylog::device::streamer::ReceiveKeepalive &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_pushreference(lua_State *L, ::zippylog::device::streamer::ReceiveKeepalive *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_has_id(lua_State *L);

// optional bytes subscription = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_clear_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_get_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_set_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ReceiveKeepalive_has_subscription(lua_State *L);

// end of message ReceiveKeepalive

// Message SubscriptionRenewedFromKeepalive
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_pushcopy(lua_State *L, const ::zippylog::device::streamer::SubscriptionRenewedFromKeepalive &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_pushreference(lua_State *L, ::zippylog::device::streamer::SubscriptionRenewedFromKeepalive *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_has_id(lua_State *L);

// optional bytes subscription = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_clear_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_get_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_set_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_SubscriptionRenewedFromKeepalive_has_subscription(lua_State *L);

// end of message SubscriptionRenewedFromKeepalive

// Message RejectKeepaliveUnknownSubscription
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_pushcopy(lua_State *L, const ::zippylog::device::streamer::RejectKeepaliveUnknownSubscription &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_pushreference(lua_State *L, ::zippylog::device::streamer::RejectKeepaliveUnknownSubscription *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_has_id(lua_State *L);

// optional bytes subscription = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_clear_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_get_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_set_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_RejectKeepaliveUnknownSubscription_has_subscription(lua_State *L);

// end of message RejectKeepaliveUnknownSubscription

// Message ErrorRenewingSubscription
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_pushcopy(lua_State *L, const ::zippylog::device::streamer::ErrorRenewingSubscription &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_pushreference(lua_State *L, ::zippylog::device::streamer::ErrorRenewingSubscription *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_clear(lua_State *L);

// optional bytes id = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_clear_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_get_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_set_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_has_id(lua_State *L);

// optional bytes subscription = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_clear_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_get_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_set_subscription(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_device_streamer_ErrorRenewingSubscription_has_subscription(lua_State *L);

// end of message ErrorRenewingSubscription

#ifdef __cplusplus
}
#endif

#endif