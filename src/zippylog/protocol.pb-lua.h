// Generated by the lua-protobuf compiler.
// You shouldn't be editing this file manually
//
// source proto file: zippylog/protocol.proto

#ifndef LUA_PROTOBUF_zippylog_protocol_H
#define LUA_PROTOBUF_zippylog_protocol_H

#include "lua-protobuf.h"
#include <zippylog/protocol.pb.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <lua.h>

// register all messages in this package to a Lua state
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_open(lua_State *L);

// Message StreamInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StreamInfo_pushcopy(lua_State *L, const ::zippylog::protocol::StreamInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StreamInfo_pushreference(lua_State *L, ::zippylog::protocol::StreamInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_clear(lua_State *L);

// optional string path = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_has_path(lua_State *L);

// optional uint64 length = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_clear_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_get_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_set_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfo_has_length(lua_State *L);

// end of message StreamInfo

// Message StreamSetInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StreamSetInfo_pushcopy(lua_State *L, const ::zippylog::protocol::StreamSetInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StreamSetInfo_pushreference(lua_State *L, ::zippylog::protocol::StreamSetInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_clear(lua_State *L);

// optional string path = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_has_path(lua_State *L);

// repeated message stream = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_clear_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_get_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_set_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_size_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfo_add_stream(lua_State *L);

// end of message StreamSetInfo

// Message BucketInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_BucketInfo_pushcopy(lua_State *L, const ::zippylog::protocol::BucketInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_BucketInfo_pushreference(lua_State *L, ::zippylog::protocol::BucketInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_clear(lua_State *L);

// optional string path = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_has_path(lua_State *L);

// repeated message stream_set = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_clear_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_get_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_set_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_size_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfo_add_stream_set(lua_State *L);

// end of message BucketInfo

// Message StoreInfo
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfo_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreInfo_pushcopy(lua_State *L, const ::zippylog::protocol::StoreInfo &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreInfo_pushreference(lua_State *L, ::zippylog::protocol::StoreInfo *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfo_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfo_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfo_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfo_clear(lua_State *L);

// repeated message bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfo_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfo_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfo_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfo_size_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfo_add_bucket(lua_State *L);

// end of message StoreInfo

// Message StoreChangeStreamAdded
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeStreamAdded &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeStreamAdded *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_clear(lua_State *L);

// optional string bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_has_bucket(lua_State *L);

// optional string stream_set = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_clear_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_get_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_set_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_has_stream_set(lua_State *L);

// optional string stream = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_clear_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_get_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_set_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_has_stream(lua_State *L);

// optional uint64 length = 4
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_clear_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_get_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_set_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAdded_has_length(lua_State *L);

// end of message StoreChangeStreamAdded

// Message StoreChangeStreamDeleted
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeStreamDeleted &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeStreamDeleted *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_clear(lua_State *L);

// optional string bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_has_bucket(lua_State *L);

// optional string stream_set = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_clear_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_get_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_set_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_has_stream_set(lua_State *L);

// optional string stream = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_clear_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_get_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_set_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_has_stream(lua_State *L);

// optional uint64 length = 4
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_clear_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_get_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_set_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeleted_has_length(lua_State *L);

// end of message StoreChangeStreamDeleted

// Message StoreChangeStreamAppended
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeStreamAppended &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeStreamAppended *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_clear(lua_State *L);

// optional string bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_has_bucket(lua_State *L);

// optional string stream_set = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_clear_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_get_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_set_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_has_stream_set(lua_State *L);

// optional string stream = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_clear_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_get_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_set_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_has_stream(lua_State *L);

// optional uint64 length = 4
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_clear_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_get_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_set_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppended_has_length(lua_State *L);

// end of message StoreChangeStreamAppended

// Message StoreChangeBucketAdded
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAdded_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeBucketAdded_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeBucketAdded &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeBucketAdded_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeBucketAdded *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAdded_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAdded_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAdded_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAdded_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAdded_clear(lua_State *L);

// optional string bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAdded_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAdded_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAdded_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAdded_has_bucket(lua_State *L);

// end of message StoreChangeBucketAdded

// Message StoreChangeBucketDeleted
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeleted_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeBucketDeleted_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeBucketDeleted &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeBucketDeleted_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeBucketDeleted *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeleted_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeleted_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeleted_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeleted_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeleted_clear(lua_State *L);

// optional string bucket = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeleted_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeleted_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeleted_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeleted_has_bucket(lua_State *L);

// end of message StoreChangeBucketDeleted

// Message StoreChangeStreamSetAdded
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeStreamSetAdded &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeStreamSetAdded *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_clear(lua_State *L);

// optional string bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_has_bucket(lua_State *L);

// optional string stream_set = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_clear_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_get_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_set_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAdded_has_stream_set(lua_State *L);

// end of message StoreChangeStreamSetAdded

// Message StoreChangeStreamSetDeleted
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeStreamSetDeleted &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeStreamSetDeleted *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_clear(lua_State *L);

// optional string bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_has_bucket(lua_State *L);

// optional string stream_set = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_clear_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_get_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_set_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeleted_has_stream_set(lua_State *L);

// end of message StoreChangeStreamSetDeleted

#ifdef __cplusplus
}
#endif

#endif