// Generated by the lua-protobuf compiler.
// You shouldn't be editing this file manually
//
// source proto file: zippylog/protocol.proto

#ifndef LUA_PROTOBUF_zippylog_protocol_H
#define LUA_PROTOBUF_zippylog_protocol_H

#include "lua-protobuf.h"
#include <zippylog/protocol.pb.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <lua.h>

// register all messages in this package to a Lua state
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_open(lua_State *L);

// Message StreamInfoV1
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StreamInfoV1_pushcopy(lua_State *L, const ::zippylog::protocol::StreamInfoV1 &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StreamInfoV1_pushreference(lua_State *L, ::zippylog::protocol::StreamInfoV1 *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_clear(lua_State *L);

// required string path = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_has_path(lua_State *L);

// optional uint64 length = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_clear_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_get_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_set_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamInfoV1_has_length(lua_State *L);

// end of message StreamInfoV1

// Message StreamSetInfoV1
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StreamSetInfoV1_pushcopy(lua_State *L, const ::zippylog::protocol::StreamSetInfoV1 &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StreamSetInfoV1_pushreference(lua_State *L, ::zippylog::protocol::StreamSetInfoV1 *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_clear(lua_State *L);

// required string path = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_has_path(lua_State *L);

// repeated message stream = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_clear_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_get_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_set_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_size_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StreamSetInfoV1_add_stream(lua_State *L);

// end of message StreamSetInfoV1

// Message BucketInfoV1
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_BucketInfoV1_pushcopy(lua_State *L, const ::zippylog::protocol::BucketInfoV1 &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_BucketInfoV1_pushreference(lua_State *L, ::zippylog::protocol::BucketInfoV1 *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_clear(lua_State *L);

// required string path = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_clear_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_get_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_set_path(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_has_path(lua_State *L);

// repeated message stream_set = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_clear_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_get_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_set_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_size_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_BucketInfoV1_add_stream_set(lua_State *L);

// end of message BucketInfoV1

// Message StoreInfoV1
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfoV1_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreInfoV1_pushcopy(lua_State *L, const ::zippylog::protocol::StoreInfoV1 &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreInfoV1_pushreference(lua_State *L, ::zippylog::protocol::StoreInfoV1 *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfoV1_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfoV1_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfoV1_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfoV1_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfoV1_clear(lua_State *L);

// repeated message bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfoV1_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfoV1_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfoV1_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfoV1_size_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreInfoV1_add_bucket(lua_State *L);

// end of message StoreInfoV1

// Message StoreChangeStreamAddedV1
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeStreamAddedV1 &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeStreamAddedV1 *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_clear(lua_State *L);

// required string bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_has_bucket(lua_State *L);

// required string stream_set = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_clear_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_get_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_set_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_has_stream_set(lua_State *L);

// required string stream = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_clear_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_get_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_set_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_has_stream(lua_State *L);

// optional uint64 length = 4
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_clear_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_get_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_set_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAddedV1_has_length(lua_State *L);

// end of message StoreChangeStreamAddedV1

// Message StoreChangeStreamDeletedV1
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeStreamDeletedV1 &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeStreamDeletedV1 *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_clear(lua_State *L);

// required string bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_has_bucket(lua_State *L);

// required string stream_set = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_clear_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_get_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_set_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_has_stream_set(lua_State *L);

// required string stream = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_clear_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_get_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_set_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_has_stream(lua_State *L);

// optional uint64 length = 4
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_clear_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_get_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_set_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamDeletedV1_has_length(lua_State *L);

// end of message StoreChangeStreamDeletedV1

// Message StoreChangeStreamAppendedV1
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeStreamAppendedV1 &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeStreamAppendedV1 *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_clear(lua_State *L);

// required string bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_has_bucket(lua_State *L);

// required string stream_set = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_clear_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_get_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_set_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_has_stream_set(lua_State *L);

// required string stream = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_clear_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_get_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_set_stream(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_has_stream(lua_State *L);

// optional uint64 length = 4
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_clear_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_get_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_set_length(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamAppendedV1_has_length(lua_State *L);

// end of message StoreChangeStreamAppendedV1

// Message StoreChangeBucketAddedV1
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAddedV1_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeBucketAddedV1_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeBucketAddedV1 &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeBucketAddedV1_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeBucketAddedV1 *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAddedV1_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAddedV1_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAddedV1_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAddedV1_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAddedV1_clear(lua_State *L);

// required string bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAddedV1_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAddedV1_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAddedV1_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketAddedV1_has_bucket(lua_State *L);

// end of message StoreChangeBucketAddedV1

// Message StoreChangeBucketDeletedV1
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeletedV1_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeBucketDeletedV1_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeBucketDeletedV1 &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeBucketDeletedV1_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeBucketDeletedV1 *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeletedV1_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeletedV1_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeletedV1_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeletedV1_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeletedV1_clear(lua_State *L);

// required string bucket = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeletedV1_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeletedV1_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeletedV1_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeBucketDeletedV1_has_bucket(lua_State *L);

// end of message StoreChangeBucketDeletedV1

// Message StoreChangeStreamSetAddedV1
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeStreamSetAddedV1 &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeStreamSetAddedV1 *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_clear(lua_State *L);

// required string bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_has_bucket(lua_State *L);

// required string stream_set = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_clear_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_get_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_set_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetAddedV1_has_stream_set(lua_State *L);

// end of message StoreChangeStreamSetAddedV1

// Message StoreChangeStreamSetDeletedV1
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_pushcopy(lua_State *L, const ::zippylog::protocol::StoreChangeStreamSetDeletedV1 &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_pushreference(lua_State *L, ::zippylog::protocol::StoreChangeStreamSetDeletedV1 *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_clear(lua_State *L);

// required string bucket = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_clear_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_get_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_set_bucket(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_has_bucket(lua_State *L);

// required string stream_set = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_clear_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_get_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_set_stream_set(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_StoreChangeStreamSetDeletedV1_has_stream_set(lua_State *L);

// end of message StoreChangeStreamSetDeletedV1

// Message PluginStateV1
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_PluginStateV1_pushcopy(lua_State *L, const ::zippylog::protocol::PluginStateV1 &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_zippylog_protocol_PluginStateV1_pushreference(lua_State *L, ::zippylog::protocol::PluginStateV1 *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_clear(lua_State *L);

// required string name = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_clear_name(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_get_name(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_set_name(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_has_name(lua_State *L);

// required enum state = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_clear_state(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_get_state(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_set_state(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_has_state(lua_State *L);

// optional enum error_code = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_clear_error_code(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_get_error_code(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_set_error_code(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_has_error_code(lua_State *L);

// optional string error_message = 4
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_clear_error_message(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_get_error_message(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_set_error_message(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_has_error_message(lua_State *L);

// required uint32 lua_current_memory = 5
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_clear_lua_current_memory(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_get_lua_current_memory(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_set_lua_current_memory(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_has_lua_current_memory(lua_State *L);

// required uint32 lua_max_memory = 6
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_clear_lua_max_memory(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_get_lua_max_memory(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_set_lua_max_memory(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_zippylog_protocol_PluginStateV1_has_lua_max_memory(lua_State *L);

// end of message PluginStateV1

#ifdef __cplusplus
}
#endif

#endif