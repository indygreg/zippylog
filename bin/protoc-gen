#!/usr/bin/python

#  Copyright 2010 Gregory Szorc
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# this is a compiler plugin for protoc
# see http://code.google.com/apis/protocolbuffers/docs/reference/other.html
#
# this plugin is likely executed by pblog_compile
# it inserts the pblog enumerations into the generated files built by protoc
# currently, it only supports Python, but that will change as things mature

from json import dump, load
from google.protobuf.compiler.plugin_pb2 import CodeGeneratorRequest, CodeGeneratorResponse
from os import environ
from os.path import basename, dirname, exists
from sys import argv, stdin, stdout, stderr

def python_output_name(filename):
    return filename.replace('.proto', '_pb2.py')

def cpp_output_header(filename):
    return filename.replace('.proto', '.pb.h')

def cpp_output_source(filename):
    return filename.replace('.proto', '.pb.cc')

serialized = stdin.read()

request = CodeGeneratorRequest()
request.ParseFromString(serialized)

response = CodeGeneratorResponse()

# this will be set by pblog_compile
if 'PBLOG_STATE_FILE' not in environ:
    response.error = 'PBLOG_STATE_FILE environment variable not defined'
    stdout.write(response.SerializeToString())
    exit(0)

mode = basename(argv[0])
if mode.find('protoc-gen-') != 0 or mode[-3:] != '_pb':
    response.error = 'protoc-gen not invoked properly. did you use pblog_compile?'
    stdout.write(response.SerializeToString())
    exit(0)

mode = mode[11:]
mode = mode[:-3]

state_file = environ['PBLOG_STATE_FILE']

state = { 'namespaces': {} }
namespaces = { 'by_index': {}, 'by_name': {} }
messages = {}
if exists(state_file):
    with open(state_file, 'r') as fh:
        state = load(fh)

        # hackery to get around JSON ints as keys issues
        # beats casting later on, IMO
        for k, v in state['namespaces'].iteritems():
            namespaces['by_index'][int(v)] = k
            namespaces['by_name'][k] = v
            messages[k] = {}

            for name, enum in state['messages'][k].iteritems():
                messages[k][name] = int(enum)

# pblog namespace is special. ensure it is always present
namespaces['by_index'][1] = 'pblog'
namespaces['by_name']['pblog'] = 1
if 'pblog' not in messages:
    messages['pblog'] = {}

if 'PBLOG_CPP_MESSAGES_NAMESPACE' in environ:
    state['cpp_messages_namespace'] = environ['PBLOG_CPP_MESSAGES_NAMESPACE']
elif 'cpp_messages_namespace' not in state:
    state['cpp_messages_namespace'] = 'pblog::site'

cpp_messages_source = state['cpp_messages_namespace'].replace('::', '/') + '/messages.cpp'
cpp_messages_header = state['cpp_messages_namespace'].replace('::', '/') + '/messages.hpp'

if mode == 'cpp':
    namespace_header = ''
    namespace_footer = ''
    for f in state['cpp_messages_namespace'].split('::'):
        namespace_header += 'namespace %s {\n' % f
        namespace_footer += '}'

    f = response.file.add()
    f.name = cpp_messages_header
    f.content = '''
// this file is automatically generated. you are highly discouraged from
// editing it manually
#include <pblog/pblog.h>

// @@protoc_insertion_point(includes)

%s
    PBLOG_EXPORT void register_known_messages();
%s
''' % ( namespace_header, namespace_footer )

    f = response.file.add()
    f.name = cpp_messages_source
    f.content = '''
// this file is automatically generated. you are highly discouraged from
// editing it manually

#include <%s>
#include <pblog/message_registrar.hpp>

%s
    void register_known_messages()
    {
        ::pblog::MessageRegistrar *registrar = ::pblog::MessageRegistrar::instance();

        // @@protoc_insertion_point(message_registration)
    }
%s
''' % ( cpp_messages_header, namespace_header, namespace_footer )

# TODO do we care about the deterministic nature of these loops?
for i in range(0, len(request.file_to_generate)):
    filename = request.file_to_generate[i]
    description = request.proto_file[i]

    namespace = dirname(filename)
    if namespace.find('/') > 0:
        namespace = namespace[:namespace.find('/')]

    package = description.package
    py_module = description.name.replace('.proto', '_pb2').replace('/', '.')
    cpp_namespace = '::' + package.replace('.', '::')

    ns_index = None

    if namespace not in namespaces['by_name']:
        ns_index = len(namespaces['by_name']) + 1
        if ns_index in namespaces['by_index']:
            response.error = 'namespace index (%d) already seen' % ns_index
            stdout.write(response.SerializeToString())
            exit(0)

        namespaces['by_name'][namespace] = ns_index
        namespaces['by_index'][ns_index] = namespace
        messages[namespace] = {}
    else:
        ns_index = namespaces['by_name'][namespace]

    for message in description.message_type:
        name = message.name
        full = '%s.%s' % ( package, name )

        message_index = None
        if full in messages[namespace]:
            message_index = messages[namespace][full]
        else:
            message_index = len(messages[namespace]) + 1
            messages[namespace][full] = message_index

        if mode == 'python':
            f = response.file.add()
            f.name = python_output_name(filename)
            f.insertion_point = 'class_scope:%s.%s' % ( package, name )
            f.content = 'PBLOG_NAMESPACE = %d\nPBLOG_ENUMERATION = %d' % ( ns_index, message_index )

            # file is included by envelope.py
            if package != 'pblog.message':
                f = response.file.add()
                f.name = python_output_name(filename)
                f.insertion_point = 'module_scope'
                f.content = "register_message(%d, %d, '%s', '%s')" % ( ns_index, message_index, py_module, name )
        elif mode == 'cpp':
            f = response.file.add()
            f.name = cpp_output_header(filename)
            f.insertion_point = 'class_scope:%s.%s' % ( package, name )
            f.content = 'static const ::google::protobuf::uint32 pblog_namespace = %d;' % ns_index

            f = response.file.add()
            f.name = cpp_output_header(filename)
            f.insertion_point = 'class_scope:%s.%s' % ( package, name )
            f.content = 'static const ::google::protobuf::uint32 pblog_enumeration = %d;' % message_index
            
            if package != 'pblog.message' and package[0:6] != 'google':
                f = response.file.add()
                f.name = cpp_output_header(filename)
                f.insertion_point = 'class_scope:%s.%s' % ( package, name )
                f.content = 'bool add_to_envelope(::pblog::Envelope *envelope);';

                f = response.file.add()
                f.name = cpp_output_source(filename)
                f.insertion_point = 'namespace_scope'
                f.content = '''
bool %s::add_to_envelope(::pblog::Envelope *envelope) {
    return envelope->add_message(this, pblog_namespace, pblog_enumeration);
}''' % name
            
                f = response.file.add()
                f.name = cpp_messages_source
                f.insertion_point = 'message_registration'
                f.content = 'registrar->register_message(%d, %d, new %s::%s());' % ( ns_index, message_index, cpp_namespace, name)

    if mode == 'python' and package != 'pblog.message':
            f = response.file.add()
            f.insertion_point = 'imports'
            f.name = python_output_name(filename)
            f.content = 'from pblog.envelope import register_message'
    elif mode == 'cpp':
        if package != 'pblog.message':
            f = response.file.add()
            f.insertion_point = 'includes'
            f.name = cpp_output_header(filename)
            f.content = '#include <pblog/envelope.hpp>'

        if package[0:6] != 'google':
            f = response.file.add()
            f.name = cpp_messages_header
            f.insertion_point = 'includes'
            f.content = '#include <%s>' % cpp_output_header(filename)

state['messages'] = messages
state['namespaces'] = namespaces['by_name']

with open(state_file, 'w') as fh:
    dump(state, fh, indent=2)

stdout.write(response.SerializeToString())
exit(0)

