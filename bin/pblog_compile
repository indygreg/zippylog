#!/usr/bin/python

#  Copyright 2010 Gregory Szorc
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import json
import subprocess
from optparse import OptionParser
import os
from os.path import exists
import re
from sys import exit

parser = OptionParser(description="""
Generates Protocol Buffer extensions for all defined messages
""",
usage='%prog [options] /path/to/messages /output/path')
parser.add_option('-p', '--protoc', default='/usr/bin/protoc', help='Path to protoc binary')

(options, args) = parser.parse_args()

if len(args) != 2:
    print 'program requires exactly two arguments. run with --help'
    exit(1)

if not exists(options.protoc):
    print '%s does not exist. consider specifying path explicitly' % options.protoc
    exit(1)

messages_dir = args[0]

if not exists(messages_dir):
    print 'message directory %s does not exist' % messages_dir
    exit(1)

out_dir = args[1]
if not exists(os.path.join(out_dir, 'pblog', 'site')):
    os.makedirs(os.path.join(out_dir, 'pblog', 'site'))

# read in existing config
state_file = os.path.join(out_dir, 'pblog-state.json')
extensions_file = os.path.join(out_dir, 'pblog', 'site', 'extensions.proto')
messagetypes_file = os.path.join(out_dir, 'pblog', 'site', 'MessageTypes.proto')

state = { 'field_message_map':[], 'next_field_index': 100, 'extension_names':[] }
if exists(state_file):
    with open(state_file, 'r') as f:
        state = json.load(f)

message_files = []
for root, dirs, files in os.walk(args[0]):
    for f in filter(lambda x: x[-6:] == '.proto', files):
        message_files.append(os.path.join(root, f))

re_package = re.compile(r'package\s(?P<package>[^;]+)')
re_message = re.compile(r'message\s(?P<message>[^\s]+)')

for file in sorted(message_files):
    with open(file, 'r') as f:
        package = None
        for line in f:
            match = re_package.match(line)
            if match:
                package = match.group('package')
                continue

            match = re_message.match(line)
            if not match:
                continue

            if not package:
                raise Exception('message definition seen in %s before package declaration' % file)

            message = '.'.join([package, match.group('message')])
            if message in state['extension_names']:
                continue

            # add it to the list
            state['field_message_map'].append( ( state['next_field_index'], message ) )
            state['extension_names'].append(message)

            # field numbers 19000-19999 are reserved by Protocol Buffers
            if state['next_field_index'] == 18999:
                state['next_field_index'] = 20000
            # field numbers 50000-99999 are reserved for options
            elif state['next_field_index'] == 49999:
                state['next_field_index'] = 100000
            else:
                state['next_field_index'] = state['next_field_index'] + 1

        if not package:
            raise Exception('%s does not define a package' % file)                

# write out state file
with open(state_file, 'w') as f:
    json.dump(state, f, indent=2, sort_keys=True)

# now produce our extensions file
with open(extensions_file, 'w') as f:
    f.write('// THIS FILE IS AUTOMATICALLY GENERATED.\n')
    f.write('// DO NOT EDIT THIS FILE BY HAND\n')
    f.write('import "pblog/pblog.proto";\n')

    for file in message_files:
        f.write('import "%s";\n' % file[len(messages_dir)+1:])

    f.write('\n')
    f.write('extend pblog.LogEvent {\n')
    f.write('\n')

    for t in state['field_message_map']:
        f.write('  optional %s %s = %d;\n' % (t[1], t[1].replace('.', '_'), t[0]))
    f.write('}\n')

with open(messagetypes_file, 'w') as f:
    f.write('// THIS FILE IS AUTOMATICALLY GENERATED\n')
    f.write('// DO NOT EDIT THIS FILE BY HAND\n')

    f.write('package pblog.site;\n')
    f.write('// look up extension field name by number\n')
    f.write('enum MessageType {\n')
    for t in state['field_message_map']:
        f.write('  %s = %d;\n' % (t[1].upper().replace('.', '_'), t[0]))
    f.write('}\n')

