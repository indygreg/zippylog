#!/usr/bin/python

#  Copyright 2010 Gregory Szorc
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import json
import subprocess
from optparse import OptionParser
import os
from os.path import exists
import re
import StringIO
from sys import exit

parser = OptionParser(description='''Generates Protocol Buffer extensions for all defined messages

On first run, you must specify an enumerations package (-e/--enums-package) to
be used for produced enumerations. After first run, this value will be cached.
''',
usage='%prog [options] /path/to/messages /output/path')

parser.add_option('-p', '--protoc', default='/usr/bin/protoc', help='Path to protoc binary')
parser.add_option('-e', '--enums-package', help='protocol buffer package to use for generated type enumerations')

(options, args) = parser.parse_args()

if len(args) != 2:
    print 'program requires exactly two arguments. run with --help'
    exit(1)

if not exists(options.protoc):
    print '%s does not exist. consider specifying path explicitly' % options.protoc
    exit(1)

messages_dir = args[0]

if not exists(messages_dir):
    print 'message directory %s does not exist' % messages_dir
    exit(1)

out_dir = args[1]

# read in existing config
state_file = os.path.join(out_dir, 'pblog-state.json')

state = { 
    'key_message_map':[],
    'next_key_index': 100,
    'message_names':[],
    'py_modules':[],
}

if exists(state_file):
    with open(state_file, 'r') as f:
        state = json.load(f)

if 'enums_package' not in state:
    if options.enums_package:
        state['enums_package'] = options.enums_package
    else:
        print 'no enums package registered. please run with --enums-package defined'
        exit(1)

enums_file = os.path.join(out_dir, state['enums_package'].replace('.', os.sep), 'pblog_types.proto')
site_pblog_file = os.path.join(out_dir, 'py', state['enums_package'].replace('.', os.sep), 'pblog_types.py')

if not exists(os.path.dirname(enums_file)):
    os.makedirs(os.path.dirname(enums_file))

if not exists(os.path.dirname(site_pblog_file)):
    os.makedirs(os.path.dirname(site_pblog_file))

message_files = []
for root, dirs, files in os.walk(messages_dir):
    for f in filter(lambda x: x[-6:] == '.proto', files):
        message_files.append(os.path.join(root, f))

re_message = re.compile(r'message\s(?P<message>[^\s]+)')

state_changed = False

for filename in sorted(message_files):
    with open(filename, 'r') as f:
        package = filename[len(messages_dir)+1:].replace('.proto', '').replace('/', '.')
        for line in f:
            match = re_message.match(line)
            if not match:
                continue

            message = '.'.join([package, match.group('message')])
            if message in state['message_names']:
                continue

            state_changed = True
            print 'new message: %s found in %s' % ( message, filename )
            
            # add it to the list
            state['key_message_map'].append( ( state['next_key_index'], message ) )
            state['message_names'].append(message)

            state['next_key_index'] += 1

for m in state['message_names']:
    py_module = m.split('.')[:-1]
    py_module = '.'.join(py_module) + '_pb2'

    if py_module not in state['py_modules']:
        state['py_modules'].append(py_module)

def message_type_enums(state):
    o = StringIO.StringIO()
    o.write('// THIS FILE IS AUTOMATICALLY GENERATED\n')
    o.write('// DO NOT EDIT THIS FILE BY HAND\n')

    o.write('package %s;\n' % state['enums_package'])
    o.write('enum MessageType {\n')
    for t in state['key_message_map']:
        o.write('  %s = %d;\n' % (t[1].replace('.', '_'), t[0]))
    o.write('}\n')

    return o.getvalue()

def python_site_pblog(state):
    o = StringIO.StringIO()
    o.write('# THIS FILE IS AUTOMATICALLY GENERATED\n')
    o.write('# DO NOT EDIT THIS FILE BY HAND\n')
    o.write('\n')

    o.write('from pblog.message import register_types\n')

    for m in sorted(state['py_modules']):
        o.write('import %s\n' % m)

    o.write('import %s\n' % (state['enums_package'] + '.pblog_types_pb2'))
    o.write('\n')

    o.write('ENUMS_MODULE = %s\n' % (state['enums_package'] + '.pblog_types_pb2'))
    o.write('\n')

    o.write('# key is enumerated type value\n')
    o.write('# value is tuple of module name, class name, full name, and enum string\n')
    o.write('TYPES_BY_INDEX = {\n')
    for t in state['key_message_map']:
        cl = t[1].split('.')[:-1]
        cl = '.'.join(cl) + '_pb2'
        o.write("  %d: ( '%s', '%s', '%s', '%s'),\n" % ( t[0], cl, t[1].split('.')[-1], t[1], t[1].replace('.', '_') ) )
    o.write('}\n')
    o.write('\n')

    o.write('# key is enumerated string value, value is int constant\n')
    o.write('ENUM_BY_CLASSNAME = {\n')
    for t in state['key_message_map']:
        cl = t[1].split('.')[:-1]
        cl = '.'.join(cl) + '_pb2'
        o.write("  '%s': %d,\n" % ( '.'.join([cl, t[1].split('.')[-1]]), t[0] ) )
    o.write('}\n')
    o.write('\n')

    o.write('register_types(TYPES_BY_INDEX)\n')

    return o.getvalue()

print 'updating state file: %s' % state_file
with open(state_file, 'w') as f:
    json.dump(state, f, indent=2, sort_keys=True)

print 'writing pblog_types file: %s' % enums_file
with open(enums_file, 'w') as f:
    f.write(message_type_enums(state))

print 'writing python site pblog file %s' % site_pblog_file
with open(site_pblog_file, 'w') as fh:
    fh.write(python_site_pblog(state))

protoc_args = [ options.protoc, '-I%s' % 'proto', '-I%s' % out_dir, '-I%s' % messages_dir ]

py_out = os.path.join(out_dir, 'py')
cpp_out = os.path.join(out_dir, 'cpp')
java_out = os.path.join(out_dir, 'java')

if not exists(py_out):
    os.mkdir(py_out)
if not exists(cpp_out):
    os.mkdir(cpp_out)
if not exists(java_out):
    os.mkdir(java_out)

protoc_args.append('--python_out=%s' % py_out)
protoc_args.append('--cpp_out=%s' % cpp_out)
protoc_args.append('--java_out=%s' % java_out)

protoc_args.append(enums_file)
protoc_args.extend(message_files)

print 'executing protoc: %s' % ' '.join(protoc_args)
p = subprocess.Popen(protoc_args)
p.wait()
