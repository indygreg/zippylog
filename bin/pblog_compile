#!/usr/bin/python

#  Copyright 2010 Gregory Szorc
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import json
import subprocess
from optparse import OptionParser
import os
from os.path import exists
import re
from sys import exit

parser = OptionParser(description="""
Generates Protocol Buffer extensions for all defined messages
""",
usage='%prog [options] /path/to/messages /output/path')
parser.add_option('-p', '--protoc', default='/usr/bin/protoc', help='Path to protoc binary')

(options, args) = parser.parse_args()

if len(args) != 2:
    print 'program requires exactly two arguments. run with --help'
    exit(1)

if not exists(options.protoc):
    print '%s does not exist. consider specifying path explicitly' % options.protoc
    exit(1)

messages_dir = args[0]

if not exists(messages_dir):
    print 'message directory %s does not exist' % messages_dir
    exit(1)

out_dir = args[1]
if not exists(os.path.join(out_dir, 'pblog', 'site')):
    os.makedirs(os.path.join(out_dir, 'pblog', 'site'))

# read in existing config
state_file = os.path.join(out_dir, 'pblog-state.json')
messagetypes_file = os.path.join(out_dir, 'pblog', 'site', 'MessageTypes.proto')
lookup_file = os.path.join(out_dir, 'lookup.py')

state = { 'key_message_map':[], 'next_key_index': 100, 'message_names':[] }
if exists(state_file):
    with open(state_file, 'r') as f:
        state = json.load(f)

message_files = []
for root, dirs, files in os.walk(args[0]):
    for f in filter(lambda x: x[-6:] == '.proto', files):
        message_files.append(os.path.join(root, f))

re_package = re.compile(r'package\s(?P<package>[^;]+)')
re_message = re.compile(r'message\s(?P<message>[^\s]+)')

state_changed = False

for file in sorted(message_files):
    with open(file, 'r') as f:
        package = None
        for line in f:
            match = re_package.match(line)
            if match:
                package = match.group('package')
                continue

            match = re_message.match(line)
            if not match:
                continue

            if not package:
                raise Exception('message definition seen in %s before package declaration' % file)

            message = '.'.join([package, match.group('message')])
            if message in state['message_names']:
                continue

            state_changed = True
            print 'new message: %s found in %s' % ( message, file )
            
            # add it to the list
            state['key_message_map'].append( ( state['next_key_index'], message ) )
            state['message_names'].append(message)

            state['next_key_index'] = state['next_key_index'] + 1

        if not package:
            raise Exception('%s does not define a package' % file)                

# write out state file
if state_changed:
    print 'updating state file: %s' % state_file
    with open(state_file, 'w') as f:
        json.dump(state, f, indent=2, sort_keys=True)

    print 'writing message types file: %s' % messagetypes_file
    with open(messagetypes_file, 'w') as f:
        f.write('// THIS FILE IS AUTOMATICALLY GENERATED\n')
        f.write('// DO NOT EDIT THIS FILE BY HAND\n')

        f.write('package pblog.site;\n')
        f.write('enum MessageType {\n')
        for t in state['key_message_map']:
            f.write('  %s = %d;\n' % (t[1].replace('.', '_'), t[0]))
        f.write('}\n')

    print 'writing type lookup file: %s' % lookup_file
    with open(lookup_file, 'w') as fh:
        fh.write('# THIS FILE IS AUTOMATICALLY GENERATED\n')
        fh.write('# DO NOT EDIT THIS FILE BY HAND\n')

        fh.write('TYPES_BY_INDEX = {\n')
        for t in state['key_message_map']:
            fh.write("  %d: '%s',\n" % ( t[0], t[1] ) )
        fh.write('}\n')
