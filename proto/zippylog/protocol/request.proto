// this file describes protocol buffer messages sent by the client when
// communicating with a remote server agent
//
// Messages should have names of actions/verbs which describe the operation
// being performed.

package zippylog.protocol.request;

// just pings the server to see if it is responding
message Ping {}

// requests the server to return a message that describes features (versions,
// operations, capabilities, etc) it supports
message GetFeatures {}

// Obtains information about the store to which the server is bound.
//
// Currently, servers can only be bound to one store, so we have no
// parameters.
message GetStoreInfo {
    required uint32 version = 1;
}

// Obtain information about a specific bucket
message GetBucketInfo {
    required uint32 version = 1;
    
    // path to bucket whose info to obtain
    optional string path = 2;
}

// Obtain information about a specific stream set
message GetStreamSetInfo {
    required uint32 version = 1;
    
    optional string path = 2;
}

// Obtain information about a specific stream
message GetStreamInfo {
    required uint32 version = 1;
    
    optional string path = 2;
}

// request to download part of a stream
//
// The server likely imposes limits of how much of a stream can be downloaded
// in one request. These limits will override whatever is specified by the
// client. Therefore, the limits in the request are merely a theoretical
// maximum.
message GetStream {
    required uint32 version = 1;

    // path of stream to retrieve
    optional string path = 2;

    // offset from start of stream from which to start sending data
    // you should never "guess" the offset because the offset likely isn't
    // valid and the server may reject your request. instead, use the last
    // offset from a previous fetch
    optional uint64 start_offset = 3;

    // maximum number of bytes to send in response
    optional uint32 max_response_bytes = 4;

    // maximum number of envelopes to receive
    optional uint32 max_response_envelopes = 5;
}

// writes 1 or more already serialized envelopes to a path in the store
//
// Envelopes are defined inline in the message as serialized values. Each
// serialized envelope may or may not be deserialized on the server. Servers
// may deserialize the envelope as part of verification as well as to append
// writer information.
message WriteEnvelope {
    // the version of this message the client is sending
    required uint32 version = 1;

    // store path to write to. must be stream set or stream
    optional string path = 2;

    // list of serialized envelopes to write
    repeated bytes envelope = 3;
    
    // Whether to acknowledge the write
    //
    // If true, the server will send a WriteAck response. The default is true,
    // but it can be disabled for potential performance increases.
    //
    // Even if acknowledgement is disabled, the server will still send an
    // error response if there was something wrong with the request or the
    // request could not be fulfilled.
    optional bool acknowledge = 4 [default=true];
    
    // Request synchronous writes
    //
    // Oftentimes, a server will deliver envelopes to a queue for writing and
    // ack the write as soon as the message has been delivered. If this flag
    // is set and the server supports the feature, the server won't send an
    // ack until the envelope has actually been processed on the other side of
    // the queue.
    //
    // A true value implies acknowledge=true.
    optional bool synchronous = 5 [default=false];
}

// writes an envelope from messages
message WriteEnvelopeFromMessages {
    required uint32 version = 1;

    // store path to write to. must be stream set or stream
    optional string path = 2;

    // list of serialized protocol buffer messages to write to a single
    // envelope
    repeated bytes message = 3;

    // enumerations for protocol buffer messages
    repeated uint32 message_namespace = 4 [packed=true];
    repeated uint32 message_type = 5 [packed=true];
}

// subscribes the client to store changes
// store changes describe changes to the store. this covers creating, deletion,
// and modification of buckets, stream sets, and streams. it does not include
// actual envelopes in streams
message SubscribeStoreChanges {
    required uint32 version = 1;

    // list of store paths to subscribe to
    // if you want to subscribe to the entire store, add the value "/"
    repeated string path = 2;
}

// subscribes to newly-written envelopes
message SubscribeEnvelopes {
    required uint32 version = 1;

    // list of store paths to subscribe to
    // this can be individual streams, stream sets, buckets, or the entire
    // store ("/")
    repeated string path = 2;

    // TODO add filtering

    // Lua code that defines functionality to be executed on the server
    optional string lua_code = 3;
}

// clients need to send keepalive messages every N seconds or the server drops
// the subscription. this is that keepalive message
message SubscribeKeepalive {
    required uint32 version = 1;

    // the subscription identifier to send the keepalive for
    // this identifier is issued by the server when it accepts the
    // subscription
    optional bytes id = 2;
}

// cancels a subscription
message SubscribeCancel {
    required uint32 version = 1;

    // subscription identifier to cancel
    optional bytes id = 2;
}